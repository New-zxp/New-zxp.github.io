<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构 | Snoopy的小窝</title><meta name="author" content="Snoopy"><meta name="copyright" content="Snoopy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="数据结构学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="http://example.com/2024-02-29-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html">
<meta property="og:site_name" content="Snoopy的小窝">
<meta property="og:description" content="数据结构学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/2.jpg">
<meta property="article:published_time" content="2024-02-29T01:56:41.000Z">
<meta property="article:modified_time" content="2024-05-20T12:27:14.627Z">
<meta property="article:author" content="Snoopy">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/2.jpg"><link rel="shortcut icon" href="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/favicon.png"><link rel="canonical" href="http://example.com/2024-02-29-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//static.cloudflareinsights.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script defer="defer" data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;c283732c5e7b4e58a56ee18077e56d1d&quot;}"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-20 20:27:14'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 网站分享</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background: none"><nav id="nav"><span id="blog-info"><a href="/" title="Snoopy的小窝"><img class="site-icon" src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/favicon.png"/><span class="site-name">Snoopy的小窝</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 网站分享</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-29T01:56:41.000Z" title="发表于 2024-02-29 09:56:41">2024-02-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-20T12:27:14.627Z" title="更新于 2024-05-20 20:27:14">2024-05-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>88分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h1><p>C语言标识符只能以字母和下划线开头，不能以数字开头</p>
<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>小题考频：8</p>
<p>大题考频：11</p>
<h2 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h2><p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/1.1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png" alt="1.1数据结构的基本概念"><br><strong>基本概念</strong></p>
<ul>
<li><p><strong>数据元素</strong></p>
<p>数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成</p>
</li>
<li><p><strong>数据结构</strong></p>
<p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合</p>
</li>
<li><p><strong>数据对象</strong></p>
<p>数据对象是具有相同性质的数据元素的集合</p>
</li>
<li><p><strong>数据类型</strong></p>
<p>数据类型是一个值的集合和定义在此集合上的一组操作的总称</p>
</li>
</ul>
<p><strong>逻辑结构</strong></p>
<p>逻辑结构是指数据元素之间的逻辑关系，即从逻辑上描述数据，它与数据的存储无关，是独立于计算机的。</p>
<p><strong>存储结构</strong></p>
<p>存储结构是指数据结构在计算机中的表示，它包括数据元素的表示和关系的表示，数据的存储结构是用计算机语言实现的==逻辑结构==</p>
<ul>
<li>若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用非顺序存储，则各个元素在物理上可以是离散的</li>
<li>数据的存储结构会影响存储空间分配的方便程度</li>
<li>数据的存储结构会影响对数据运算的速度</li>
</ul>
<p><strong>主要存储结构</strong></p>
<ul>
<li>顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现，其优点是可以实现==随机存取==，每个元素占用最少的存储空间。缺点是只能使用相邻的一整块存储单元。因此可能产生较多的外部碎片。</li>
<li>链式存储：不要求逻辑上相邻的元素在物理位置上也相邻。借助指示元素存储地址的指针来表示元素之间的逻辑关系。其优点是不会出现碎片现象，能充分利用所有存储单元。缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。</li>
<li>索引存储：在存储元素信息的同时，还建立附加的索引表索引表中的每一项称为索引项索引项的一般形式是。关键字+地址。其优点是检索速度快。缺点是附加的索引表额外占用存储空间。另外增加和删除数据时也要修改索引表，因此会花费较多的时间。</li>
<li>散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希存储，其优点是检索、增加和删除节点的操作都很快。缺点是若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。</li>
</ul>
<p><strong>数据的运算</strong></p>
<p>施加在数据上的运算，包括运算的定义和实现。<strong>运算的定义</strong>是针对==逻辑结构==的，指出运算的功能；<strong>运算的实现</strong>是针对==存储结构的==，指出运算的具体操作步骤。</p>
<p><strong>错题</strong></p>
<p>抽象数据类型(ADT)，描述了数据的逻辑结构和抽象运算，通常用[数据对象，数据关系，基本操作集]这样的三元组表示，因此构成了一个完整的数据结构定义。</p>
<p>在存储数据时，不仅要存储数据元素的值，而且要存储数据元素之间的关系</p>
<h2 id="算法和算法评价"><a href="#算法和算法评价" class="headerlink" title="算法和算法评价"></a>算法和算法评价</h2><p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/1.2%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7.png" alt="1.2算法和算法评价"></p>
<p><strong>算法</strong>是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。</p>
<p>算法具有下列<strong>五个重要特性</strong>：</p>
<ul>
<li>有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成</li>
<li>确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得到相同的输出</li>
<li>可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现</li>
<li>输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。</li>
<li>输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量</li>
</ul>
<p><strong>==好算法==的特质</strong></p>
<ul>
<li>正确性：算法应该能够正确的解决求解问题。</li>
<li>可读性：算法应具有良好的可读性，以帮助人们理解</li>
<li>健壮性：算法能对输入的非法数据作出反应或处理，而不会产生莫名其妙的输出</li>
<li>高效率与低存储量需求：效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题的规模有关</li>
</ul>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>一个语句的频度是指该语句在算法中被重复执行的次数，算法中所有语句的频度之和记为T(n)，它是该算法<strong>问题规模n</strong>的函数，时间复杂度主要分析T(n)的数量级</p>
<p>常见数量级大小<br>$$<br>O(1) &lt; O(\log_2n) &lt; O(n) &lt; O(n\log_2n) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)<br>$$</p>
<ul>
<li><strong>最坏时间复杂度</strong>是指在最坏情况下，算法的时间复杂度</li>
<li><strong>平均时间复杂度</strong>是指所有可能输入实例在等概率出现的情况下，算法的期望运行时间</li>
<li><strong>最好时间复杂度</strong>是指在最好情况下算法的时间复杂度</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">love</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printg(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度T(n) = $O(\log_2n)$</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>算法的空间复杂度S(n)定义为该算法所需的存储空间，它是问题规模n的函数</p>
<p>一个程序在执行时除需要存储空间来存放本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的<strong>辅助空间</strong>。若输入数据所占空间只取决于问题本身，和算法无关，则只需分析<strong>除输入和程序之外的额外空间</strong></p>
<p><strong>算法原地工作</strong>是指算法所需的辅助空间为常量，即O(1)</p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/2.%E7%BA%BF%E6%80%A7%E8%A1%A8.png" alt="2.线性表"></p>
<p>小题考频：5</p>
<p>大题考频：12</p>
<h2 id="线性表的定义和基本操作"><a href="#线性表的定义和基本操作" class="headerlink" title="线性表的定义和基本操作"></a>线性表的定义和基本操作</h2><p>线性表是具有==相同数据类型==的n个数据元素的==有限====序列==</p>
<p>线性表的位序是从1开始的，数组的下标从0开始</p>
<p>线性表是一种==逻辑结构==，表示元素之间一对一的相邻关系。==顺序存储和链式存储是指存储结构==，两者属于不同层面的概念。</p>
<p><strong>线性表的特点</strong></p>
<ul>
<li>表中元素的个数有限</li>
<li>表中元素具有逻辑上的顺序性，表中元素有其先后次序</li>
<li>表中元素都是数据元素，每个元素都是单个元素</li>
<li>表中元素的数据类型相同，这意味着每个元素占有相同大小的存储空间</li>
<li>表中元素具有抽象性。仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。</li>
</ul>
<p><strong>线性表的基本操作</strong></p>
<ul>
<li>InitList(&amp;L)：初始化表。构造一个空的线性表L，分配内存空间</li>
<li>DestriyList(&amp;L)：销毁操作，销毁线性表，并释放线性表L所占用的内存空间</li>
<li>ListInsert(&amp;L,i,e)：插入操作，在表L中的第i个位置插入指定元素e</li>
<li>ListDelete(&amp;L,i,&amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值</li>
<li>LocateElem(L,e)：按值查找操作，在表L中查找具有给定关键字值的元素</li>
<li>GetElem(L,i)：按位查找操作，获取表L中第i个位置的元素的值</li>
<li>Length(L)：求表长，返回线性表L的长度，即L中数据元素的个数</li>
<li>PrintList(L)：输出操作，按前后顺序输出线性表L的所有元素值</li>
<li>Empty(L)：判空操作，若L为空表，返回true，否则返回false</li>
</ul>
<h2 id="线性表的顺序表示——顺序表"><a href="#线性表的顺序表示——顺序表" class="headerlink" title="线性表的顺序表示——顺序表"></a>线性表的顺序表示——顺序表</h2><p><strong>顺序表</strong>——用顺序存储(物理结构)的形式实现线性表(逻辑结构)</p>
<p><strong>顺序存储</strong>(物理结构)：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现</p>
<p>假设顺序表L存储的起始位置为LOC(A)，那么第n个元素的为内存地址为LOC(A) + (n-1) * sizeof(元素数据类型)</p>
<p><strong>顺序表的特点</strong></p>
<ul>
<li>随机访问，即可以在O(1)时间内找到第i个元素</li>
<li>存储密度高，每个节点只存储数据元素</li>
<li>拓张容量不方便</li>
<li>插入、删除操作不方便，需要移动大量元素</li>
</ul>
<p><strong>静态分配</strong>的顺序表存储结构描述为：</p>
<p>销毁：生命周期结束后，系统自动回收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50			<span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>			</span><br><span class="line">	ElemType data[MaxSize];	<span class="comment">//用静态的数组存放数据元素</span></span><br><span class="line">	<span class="type">int</span> length;				<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="comment">//初始化顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList *L)</span>&#123;</span><br><span class="line">    L-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>typedef struct &#123;...&#125; SqList;</code>：定义了一个新的数据类型 <code>SqList</code>，它是一个结构体类型，结构体中包含两个成员</p>
<p><strong>动态分配</strong>的顺序表存储结构描述为：</p>
<p>销毁：手动free</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10			<span class="comment">//定义顺序表的初始长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>			</span><br><span class="line">	ElemType *data;			<span class="comment">//指向动态分配数组的指针</span></span><br><span class="line">	<span class="type">int</span> MaxSize;			<span class="comment">//数组的最大容量</span></span><br><span class="line">	<span class="type">int</span> length;				<span class="comment">//数组当前长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList *L)</span>&#123;</span><br><span class="line">	L-&gt;data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * InitSize);<span class="comment">//申请一片连续的储存空间</span></span><br><span class="line">	L-&gt;length = <span class="number">0</span>;</span><br><span class="line">	L-&gt;MaxSize = InitSize;	<span class="comment">//将最大容量初始化为初始大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态申请和释放空间内存</strong>：malloc和free函数</p>
<p><code>L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> 		<span class="comment">//malloc和free函数头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> *data;				<span class="comment">//指向动态分配数组的指针</span></span><br><span class="line">	<span class="type">int</span> MaxSize;			<span class="comment">//当前分配的存储空间的最大容量</span></span><br><span class="line">	<span class="type">int</span> length;				<span class="comment">//顺序表当前长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList *L)</span>&#123;</span><br><span class="line">	L-&gt;data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * InitSize);<span class="comment">//申请一片连续的储存空间</span></span><br><span class="line">	L-&gt;length = <span class="number">0</span>;</span><br><span class="line">	L-&gt;MaxSize = InitSize;	<span class="comment">//将最大容量初始化为初始大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加容量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IncreaseSize</span><span class="params">(SqList *L, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	<span class="type">int</span>* p = L-&gt;data;<span class="comment">//定义一个指针p，和data指针指向同一个位置</span></span><br><span class="line">	L-&gt;data = (<span class="type">int</span>*)<span class="built_in">malloc</span>((L-&gt;MaxSize + len) * <span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//申请新的存储空间</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L-&gt;length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		L-&gt;data[i] = p[i];<span class="comment">//将数据复制到新区域</span></span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;MaxSize = L-&gt;MaxSize + len;</span><br><span class="line">	<span class="built_in">free</span>(p);<span class="comment">//释放原来的空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>插入操作</strong>(静态)</p>
<p>ListInsert(&amp;L,i,e)：插入操作，在表L中的第i个位置插入指定元素e</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ListInsert</span><span class="params">(SqList *L,<span class="type">int</span> i, <span class="type">int</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = L-&gt;length;j &gt;= i;j--)<span class="comment">//将第i个元素之后的元素后移</span></span><br><span class="line">        L-&gt;data[j]=L-&gt;data[j<span class="number">-1</span>];</span><br><span class="line">    L.data[i<span class="number">-1</span>] = e;</span><br><span class="line">    L.length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>删除操作</strong>(静态)</p>
<p>ListDelete(&amp;L,i,&amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(SqList *L,<span class="type">int</span> i,<span class="type">int</span> *e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e=L-&gt;data[i<span class="number">-10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;L-&gt;length;j++)</span><br><span class="line">        L-&gt;data[j<span class="number">-1</span>]=L-&gt;Data[j];</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>按位查找</strong>(静态)</p>
<p>GetElem(L,i)：按位查找操作，获取表L中第i个位置的元素的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ElemType <span class="title function_">GetElme</span><span class="params">(SqList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.data[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>按值查找</strong></p>
<p>LocateElem(L,e)：按值查找操作，在表L中查找具有给定关键字值的元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqList L,ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; L.length;i++)</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] == e)</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;<span class="comment">//返回其位序i+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线性表的链式表示——链表"><a href="#线性表的链式表示——链表" class="headerlink" title="线性表的链式表示——链表"></a>线性表的链式表示——链表</h2><p>链式存储线性表时，不需要使用地址连续的存储单元，即不要求逻辑上相邻的元素在物理位置上也相邻，插入和删除时只需要修改指针，但会失去顺序表随机存取的优点</p>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单链表是链式存储的线性表，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表节点处存放元素自身的信息之外，还需要存放一个指向其后继的指针。</p>
<p>优点：不要求大片连续空间，改变容量方便</p>
<p>缺点：不可随机存取，要耗费一定空间存放指针</p>
<p>单链表中节点的定义——方法一</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;			<span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>		<span class="comment">//指针指向下一个节点 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 申请一个节点的空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">node</span> =</span> (<span class="keyword">struct</span> LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">LNode</span>;</span></span><br></pre></td></tr></table></figure>

<p>在 C 语言中，当你在结构体内部引用它自身的类型时，需要在类型前面加上 <code>struct</code> 关键字。这是因为在声明结构体的同时，结构体类型还没有完全定义，因此需要在类型前面加上 <code>struct</code> 关键字来指明它是一个结构体类型。</p>
<p><code>typedef &lt;数据类型&gt; &lt;别名&gt;</code>给数据类型取一个别名</p>
<p>单链表中节点的定义——方法二</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;			<span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>		<span class="comment">//指针指向下一个节点 </span></span><br><span class="line">&#125;LNode,*LinkList;			<span class="comment">//使用 LinkList 来代替 struct LNode * 的类型声明</span></span><br><span class="line"><span class="comment">//要表示一个单链表时，只需声明头指针L，指向单链表的第一个节点</span></span><br><span class="line">LNode *L; 					<span class="comment">//声明一个指向单链表第一个节点的指针</span></span><br><span class="line">LinkList L;					<span class="comment">//声明一个指向单链表第一个节点的指针</span></span><br></pre></td></tr></table></figure>



<p>单链表的初始化不带头节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">initList</span><span class="params">(LinkList *L)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 返回空指针表示空链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带头节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList *L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>按位序插入</strong>(带头节点)</p>
<p>ListInsert(&amp;L,i,e)：插入操作，在表L中的第i个位置插入指定元素e</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在第i个位置插入e</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">    LNode *p = L; 	<span class="comment">// p 指向头节点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;		<span class="comment">//当前p指向第几个节点</span></span><br><span class="line">    <span class="keyword">while</span> (p!<span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123; <span class="comment">// 找到第 i - 1 个节点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) 	<span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">// 创建新节点</span></span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>指定节点的后插操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在指定节点p的后面插入元素e</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextrNode</span><span class="params">(LNode *p, ElemType e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果p为空，则无法插入</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;指定节点为空，无法插入！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">// 创建新节点</span></span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>指定节点的前插操作</p>
<p>先找到第i-1个节点，即插入节点的前驱，再对其执行后插操作，时间复杂为O(n)</p>
<p>或者偷天换日</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">// 创建新节点</span></span><br><span class="line">   <span class="keyword">if</span> (s==<span class="literal">NULL</span>) </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">   p-&gt;next = s;</span><br><span class="line">s-&gt;data = p-&gt;data;</span><br><span class="line">p-&gt;data = e;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>双链表节点中有两个指针，prior和next，分别指向其直接前驱和直接后继</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><h4 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h4><p>表中最后一个节点的指针指向头节点</p>
<h4 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h4><p>表头节点的pripr指向表尾节点，表尾节点的next指向头节点</p>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>静态链表使用数组来描述线性表的链式存储结构。节点也有数据域data和指针域next，与链表中的指针不同的是，这里的指针是节点在数组中的相对地址(数组下标，又称游标。和顺序表一样，==静态链表也要预先分配一块连续的内存空间==</p>
<p>优点：增删操作不需要移动大量元素</p>
<p>缺点：不能随机存取，只能从头节点开始依次往后查找，容量固定不变</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center">游标</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">头</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">e2</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">e1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">e4</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">e3</td>
<td align="center">3</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100 <span class="comment">// 静态链表的最大容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType; <span class="comment">// 假设 ElemType 是你所需的数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125; SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStaticLinkedList</span><span class="params">(SLinkList L)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxSize - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        L[i].next = i + <span class="number">1</span>; <span class="comment">// 每个节点的下标递增1</span></span><br><span class="line">    &#125;</span><br><span class="line">    L[MaxSize - <span class="number">1</span>].next = <span class="number">-1</span>; <span class="comment">// 最后一个节点的next指针指向-1，表示链表结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在静态链表末尾插入元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InsertAtEnd</span><span class="params">(SLinkList L, ElemType e)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L[i].next != <span class="number">-1</span>) &#123;</span><br><span class="line">        i = L[i].next; <span class="comment">// 找到最后一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == MaxSize - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;静态链表已满，无法插入！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 链表已满</span></span><br><span class="line">    &#125;</span><br><span class="line">    L[i].data = e;</span><br><span class="line">    <span class="type">int</span> new_index = L[i].next; <span class="comment">// 获取新插入元素的索引</span></span><br><span class="line">    L[i].next = L[new_index].next; <span class="comment">// 更新最后一个元素的next指针</span></span><br><span class="line">    L[new_index].data = <span class="number">-1</span>; <span class="comment">// 清空新插入元素的数据域</span></span><br><span class="line">    L[new_index].next = <span class="number">-1</span>; <span class="comment">// 新元素成为新的最后一个元素</span></span><br><span class="line">    <span class="keyword">return</span> new_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印静态链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintStaticLinkedList</span><span class="params">(SLinkList L)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L[index].next != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, L[index].data);</span><br><span class="line">        index = L[index].next; <span class="comment">// 移动到下一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    SLinkList L;</span><br><span class="line">    InitStaticLinkedList(L); <span class="comment">// 初始化静态链表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向静态链表中插入元素</span></span><br><span class="line">    InsertAtEnd(L, <span class="number">1</span>);</span><br><span class="line">    InsertAtEnd(L, <span class="number">2</span>);</span><br><span class="line">    InsertAtEnd(L, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印静态链表</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;静态链表内容：&quot;</span>);</span><br><span class="line">    PrintStaticLinkedList(L);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序表和链表比较"><a href="#顺序表和链表比较" class="headerlink" title="顺序表和链表比较"></a>顺序表和链表比较</h3><p>表长难以预估，经常要增加/删除元素用==链表==</p>
<p>表长可以预估，查询(搜索)操作较多用==顺序表==</p>
<ul>
<li><p>存取方式</p>
<ul>
<li>顺序表：可以顺序错去也可以随机存取</li>
<li>链表：只能从表头开始依次顺序存取</li>
</ul>
</li>
<li><p>逻辑结构与物理结构</p>
<p>采用顺序存储时，逻辑上相邻的元素对应的物理存储位置也相邻。而采用链式存储时，逻辑上相邻的元素物理存储位置不一定相邻。对应的逻辑关系，也是通过指针连接来表示</p>
</li>
<li><p>查找</p>
<ul>
<li><p>按值查找</p>
<p>顺序表无序时，两者时间复杂度都为O(n)；</p>
<p>顺序表有序时，可以折半查找，时间复杂度位$O(log_2n)$</p>
</li>
<li><p>按序查找</p>
<p>顺序表时间复杂度为O(1)</p>
<p>链表平均时间复杂度为O(n)</p>
</li>
</ul>
</li>
<li><p>插入和删除</p>
<p>顺序表的插入删除操作平均需要移动半个表长的元素</p>
<p>链表的插入删除操作，只需修改相关节点的指针域即可</p>
</li>
</ul>
<h1 id="栈、队列和数组"><a href="#栈、队列和数组" class="headerlink" title="栈、队列和数组"></a>栈、队列和数组</h1><p>小题考频：25</p>
<p>大题考频：4</p>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/3.%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84.png" alt="3.栈、队列和数组"></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/3.1%E6%A0%88.png" alt="3.1栈"></p>
<h3 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h3><p>栈是只允许在一端进行插入或删除操作的线性表</p>
<p><strong>特点</strong>：**==后进先出==**——Last In First Out(LIFO)</p>
<ul>
<li>栈顶：线性表允许进行插入删除的那一端</li>
<li>栈底：固定的不允许进行插入和删除的另一端</li>
<li>空栈：不含任何元素的空表</li>
</ul>
<p>栈的基本操作：</p>
<ul>
<li>**initStack(Stack* s)**：初始化栈，分配内存空间</li>
<li>**stackEmpty(Stack* s)**：判断栈是否为空</li>
<li>**push(Stack* s, ElementType item)**：入栈操作</li>
<li>**pop(Stack* s)**：出栈操作</li>
<li>**getTop(Stack* s)**：获取栈顶元素</li>
<li>**destroyStack(Stack <em>s</em>)**：销毁栈，并释放栈占用的存储空间</li>
</ul>
<p>栈的数学性质：当N个不同元素进栈时，出栈元素不同排列的个数为$$\frac{1}{n+1} \times C_{2n}^n$$</p>
<h3 id="栈的顺序存储结构——顺序栈"><a href="#栈的顺序存储结构——顺序栈" class="headerlink" title="栈的顺序存储结构——顺序栈"></a>栈的顺序存储结构——顺序栈</h3><p>采用顺序存储的栈称为顺序栈。它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附一个指针指示当前栈顶元素的位置</p>
<p>缺点：不能改变栈的大小</p>
<p><strong>顺序栈基本操作</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MaxSize]; 	<span class="comment">// 存放栈中元素的静态数组</span></span><br><span class="line">    <span class="type">int</span> top;            <span class="comment">// 栈顶指针，指向栈顶元素的位置</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initSqStack</span><span class="params">(SqStack *s)</span> &#123;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>; <span class="comment">// 栈顶指针置为-1，表示空栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SqStackEmpty</span><span class="params">(SqStack *s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否已满</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(SqStack *s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == MAX_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">push</span><span class="params">(SqStack *s, ElemType x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(s)) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;top = s-&gt;top + <span class="number">1</span>;</span><br><span class="line">    s-&gt;data[s-&gt;top] = x; 	<span class="comment">//先将栈顶指针加1，然后将元素入栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop</span><span class="params">(SqStack *s,ElemType *x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(s))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    *x = s-&gt;data[s-&gt;top];	<span class="comment">//先取出栈顶元素</span></span><br><span class="line">    s-&gt;top = s-&gt;top - <span class="number">1</span>;	<span class="comment">//然后将栈顶指针减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; 		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取栈顶元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">getTop</span><span class="params">(SqStack *s,ElemType *x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(s)) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    *x = s-&gt;data[s-&gt;top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    SqStack <span class="built_in">stack</span>;</span><br><span class="line">    initSqStack(&amp;<span class="built_in">stack</span>); <span class="comment">// 初始化栈</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈操作</span></span><br><span class="line">    push(&amp;<span class="built_in">stack</span>, <span class="number">10</span>);</span><br><span class="line">    push(&amp;<span class="built_in">stack</span>, <span class="number">20</span>);</span><br><span class="line">    push(&amp;<span class="built_in">stack</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Popped element: %d\n&quot;</span>, pop(&amp;<span class="built_in">stack</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈顶元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Top element: %d\n&quot;</span>, top(&amp;<span class="built_in">stack</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><p>让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延续。</p>
<p>两个栈的栈顶指针都指向栈顶元素，top0 = -1时，0号栈为空，top1 = Max size时，1号栈为空。仅当两个栈顶指针相邻top1 - top 0等于1时，判断为栈满。</p>
<p>共享栈是为了更有效地利用==存储空间==，两个栈的空间相互调节，只有在整个存储空间被占满时才发生==上溢==</p>
<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><p>采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享空间和提高其效率，且不存在栈满上溢的情况，通常采用单链表来实现，并规定所有操作都是在单链表的表头进行</p>
<p><strong>链栈基本操作</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链栈节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链栈结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Node* top; <span class="comment">// 栈顶指针</span></span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化链栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断链栈是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack* <span class="built_in">stack</span>, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">// 创建新节点</span></span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed. Unable to push element.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value; <span class="comment">// 设置新节点的数据</span></span><br><span class="line">    newNode-&gt;next = <span class="built_in">stack</span>-&gt;top; <span class="comment">// 将新节点插入栈顶</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = newNode; <span class="comment">// 更新栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty. Unable to pop element.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    Node* temp = <span class="built_in">stack</span>-&gt;top; <span class="comment">// 保存栈顶节点的指针</span></span><br><span class="line">    <span class="type">int</span> poppedValue = temp-&gt;data; <span class="comment">// 获取栈顶元素的值</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = temp-&gt;next; <span class="comment">// 更新栈顶指针</span></span><br><span class="line">    <span class="built_in">free</span>(temp); <span class="comment">// 释放栈顶节点的内存</span></span><br><span class="line">    <span class="keyword">return</span> poppedValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取栈顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">top</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearStack</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        pop(<span class="built_in">stack</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyStack</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    clearStack(<span class="built_in">stack</span>); <span class="comment">// 清空栈</span></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>); <span class="comment">// 释放栈所占用的内存空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Stack <span class="built_in">stack</span>;</span><br><span class="line">    initStack(&amp;<span class="built_in">stack</span>); <span class="comment">// 初始化链栈</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈操作</span></span><br><span class="line">    push(&amp;<span class="built_in">stack</span>, <span class="number">10</span>);</span><br><span class="line">    push(&amp;<span class="built_in">stack</span>, <span class="number">20</span>);</span><br><span class="line">    push(&amp;<span class="built_in">stack</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Popped element: %d\n&quot;</span>, pop(&amp;<span class="built_in">stack</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈顶元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Top element: %d\n&quot;</span>, top(&amp;<span class="built_in">stack</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁链栈</span></span><br><span class="line">    destroyStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/3.2%E9%98%9F%E5%88%97.png" alt="3.2队列"></p>
<p>队列是只允许在一端进行插入(==入队==)，在另一端删除的线性表(==出队==)</p>
<ul>
<li>队尾(rear)：允许插入的一端</li>
<li>队头(front)：允许删除的一段</li>
</ul>
<p>队列的特点：==先进先出==——First In First Out(FIFO)</p>
<p>队列的基本操作：</p>
<ul>
<li>InitQueue(&amp;Q)：初始化队列,构造一个空队列Q</li>
<li>QueueEmpty(Q)：判队列空,若队列为空返回true,否则返回false</li>
<li>EnQueue(&amp;Q,x)：入队,若队列Q未满,将x加入,使之成为新的队尾</li>
<li>DeQueue(&amp;Q,&amp;x)：出队,若队列非空,删除队头元素,并用x返回</li>
<li>GetHead (Q,&amp;x)：读队头元素,若队列非空,则将队头元素赋值给x</li>
</ul>
<h3 id="队列的顺序结构实现"><a href="#队列的顺序结构实现" class="headerlink" title="队列的顺序结构实现"></a>队列的顺序结构实现</h3><p><strong>循环队列</strong></p>
<p>队列长度：(Q.rear+ MaxSize - Q.front) % MaxSize</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100 <span class="comment">// 定义队列的最大容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype; <span class="comment">// 假设队列元素为整数类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  &#123;</span></span><br><span class="line">    Elemtype data[MaxSize];</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue *Q)</span> &#123;</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = <span class="number">0</span>; <span class="comment">// 初始时队头指针和队尾指针都指向0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(SqQueue *Q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;front == Q-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否已满</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(SqQueue *Q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (Q-&gt;rear + <span class="number">1</span>) % MaxSize == Q-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue *Q, Elemtype x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(Q)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue is full. Unable to enqueue element.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    Q-&gt;data[Q-&gt;rear] = x; <span class="comment">// 将元素放入队尾位置</span></span><br><span class="line">    Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MaxSize; <span class="comment">// 更新队尾指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队操作</span></span><br><span class="line">Elemtype <span class="title function_">DeQueue</span><span class="params">(SqQueue *Q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(Q)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue is empty. Unable to dequeue element.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    Elemtype x = Q-&gt;data[Q-&gt;front]; <span class="comment">// 取出队头元素</span></span><br><span class="line">    Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MaxSize; <span class="comment">// 更新队头指针</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取队头元素</span></span><br><span class="line">Elemtype <span class="title function_">GetFront</span><span class="params">(SqQueue *Q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(Q)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue is empty.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;data[Q-&gt;front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearQueue</span><span class="params">(SqQueue *Q)</span> &#123;</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = <span class="number">0</span>; <span class="comment">// 将队头指针和队尾指针都置为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    SqQueue Q;</span><br><span class="line">    InitQueue(&amp;Q); <span class="comment">// 初始化队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作</span></span><br><span class="line">    EnQueue(&amp;Q, <span class="number">10</span>);</span><br><span class="line">    EnQueue(&amp;Q, <span class="number">20</span>);</span><br><span class="line">    EnQueue(&amp;Q, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dequeued element: %d\n&quot;</span>, DeQueue(&amp;Q));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队头元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Front element: %d\n&quot;</span>, GetFront(&amp;Q));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空队列</span></span><br><span class="line">    ClearQueue(&amp;Q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="队列的链式存储结构——链队列"><a href="#队列的链式存储结构——链队列" class="headerlink" title="队列的链式存储结构——链队列"></a>队列的链式存储结构——链队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链式队列节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    ElemType data;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span>  </span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkQueue</span> &#123;</span></span><br><span class="line">    LinkNode *front;  <span class="comment">// 队头指针</span></span><br><span class="line">    LinkNode *rear;   <span class="comment">// 队尾指针</span></span><br><span class="line">&#125; LinkQueue;</span><br></pre></td></tr></table></figure>

<p>队列的列式表示称为链队列，它实际上是一个同时有队头指针和队尾指针的单链表</p>
<p>用单链表表示的列式队列特别适合于数据元素变动比较大的情形，而且不存在队列满且产生溢出的问题。</p>
<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>双端队列是指允许两端都可以进行插入和删除操作的线性表。双端队列两端的地位是平等的，为了方便理解，将左端也是为前端，右端也是为后端</p>
<p>输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列称为输出受限的双端队列</p>
<p>输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列称为输入受限的双端队列</p>
<h2 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h2><h3 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h3><p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/3.3.1%E6%A0%88%E5%9C%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.PNG" alt="3.3.1栈在括号匹配中的应用"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义栈的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> <span class="built_in">array</span>[MaxSize];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：创建一个新的栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：检查栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(SqStack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：将元素压入栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(SqStack* <span class="built_in">stack</span>, <span class="type">char</span> item)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top == MaxSize - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈已满，无法压入元素\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;<span class="built_in">array</span>[++<span class="built_in">stack</span>-&gt;top] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：从栈中弹出元素</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">pop</span><span class="params">(SqStack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">stack</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;<span class="built_in">array</span>[<span class="built_in">stack</span>-&gt;top--];</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;$&#x27;</span>; <span class="comment">// 栈为空时返回一个特殊字符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：检查括号是否匹配</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bracketCheck</span><span class="params">(<span class="type">char</span> str[],<span class="type">int</span> length)</span> &#123;	<span class="comment">//length：字符串长度</span></span><br><span class="line">    SqStack S;</span><br><span class="line">    initStack(S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            push(S, str[i]);	<span class="comment">//扫描到左括号，入栈</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;)&#x27;</span> || str[i] == <span class="string">&#x27;]&#x27;</span> || str[i] == <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前字符是右括号，则检查栈顶元素是否是与之匹配的左括号</span></span><br><span class="line">            <span class="keyword">if</span> (isEmpty(S)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 栈为空，括号不匹配，右括号单身</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span> topChar = pop(<span class="built_in">stack</span>);<span class="comment">//获得栈顶元素</span></span><br><span class="line">            <span class="comment">//如果右边不是与之对应的括号，直接false，这三种情况任意一个true就为true</span></span><br><span class="line">            <span class="keyword">if</span> ((str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topChar != <span class="string">&#x27;(&#x27;</span>) ||</span><br><span class="line">                (str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topChar != <span class="string">&#x27;[&#x27;</span>) ||</span><br><span class="line">                (str[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topChar != <span class="string">&#x27;&#123;&#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 括号不匹配</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果栈不为空，说明有左括号没有被匹配</span></span><br><span class="line">    <span class="type">bool</span> result = isEmpty(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入要检查的表达式：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="keyword">if</span> (bracketCheck(str))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;括号匹配正确\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;括号匹配错误\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h3><p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/3.3.2%E6%A0%88%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.png" alt="3.3.2栈在表达式求值中的应用"></p>
<p>概念：运算符、操作数、界限符（括号）</p>
<p>前缀表达式(波兰表达式)：运算符在两个操作数之前</p>
<p>中缀表达式：运算符在两个操作数中间</p>
<p>后缀表达式(逆波兰表达式)：运算符在两个操作数后面</p>
<p>中：a + b - c * d</p>
<p>前：-+ab*cd</p>
<p>后：ab+cd*-</p>
<h4 id="中缀转后缀（重点）"><a href="#中缀转后缀（重点）" class="headerlink" title="中缀转后缀（重点）"></a>中缀转后缀（重点）</h4><p>==左优先原则==：只要左边的运算符能先计算，就优先算左边的</p>
<p>中缀转后缀的手算方法：</p>
<ol>
<li>确定中缀表达式中各个运算符的运算顺序</li>
<li>确定下一个运算符，按照==[左操作数 右操作数 运算符]==的方式组合成一个新的操作数</li>
<li>如果还有运算符没被处理就继续②</li>
</ol>
<p>中缀表达式转后缀表达式（机算）：</p>
<p>初始化一个正用于保存位置，还不能确定运算顺序的运算符，从左到右处理各个元素，直到末尾，可能遇到三种情况</p>
<ul>
<li>遇到操作数，直接加入后缀表达式</li>
<li>遇到界限符。遇到<code>&quot;(&quot;</code>直接入栈；遇到<code>&quot;)&quot;</code>则依次弹出栈内运算符，并加入后缀表达式，直到弹出<code>&quot;(&quot;</code>为止。注意<code>&quot;)&quot;</code>不加入后缀表达式</li>
<li>遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到<code>&quot;(&quot;</code>或栈空则停止。之后再把当前运算符入栈</li>
</ul>
<p>按上述方法处理完所有运算符后，将栈中剩余运算符依次弹出，并加入后缀表达式</p>
<p>用栈实现后缀表达式的计算(机算)——<strong>后缀转中缀</strong></p>
<ol>
<li>从左往右扫描下一个元素，直到处理完所有元素</li>
<li>若扫描到操作数则压入栈中，并且回到①；否则执行③</li>
<li>若扫描到运算符，则弹出两个栈顶元素（先出栈的是==右操作数==），执行相应运算，运算结果压回栈顶，回到①</li>
</ol>
<p>后缀表达式的计算（手算）：从左往右扫描，每遇到一个运算符就让运算符前面最近的两个操作数执行对应运算，合体为一个操作数</p>
<p>用栈实现中对表达式的计算：</p>
<ol>
<li>初始化两个栈操作数栈和运算符栈</li>
<li>若扫描到操作数，压入操作数栈</li>
<li>若扫描到运算符或界限符，按照中缀转后缀相同的逻辑压入运算符栈，期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素，并执行相应运算，计算结果在压回操作数栈</li>
</ol>
<p><strong>代码实现计算后缀表达式</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义栈结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="type">double</span> items[MAX_SIZE];</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initialize</span><span class="params">(Stack *s)</span> &#123;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack *s, <span class="type">double</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top == MAX_SIZE - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack Overflow\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;items[++(s-&gt;top)] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">pop</span><span class="params">(Stack *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack Underflow\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;items[(s-&gt;top)--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算后缀表达式</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">evaluatePostfix</span><span class="params">(<span class="type">char</span> *expression)</span> &#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    initialize(&amp;s);</span><br><span class="line">    <span class="type">double</span> operand1, operand2, result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; expression[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(expression[i])) &#123;</span><br><span class="line">            push(&amp;s, (<span class="type">double</span>)(expression[i] - <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            operand2 = pop(&amp;s);</span><br><span class="line">            operand1 = pop(&amp;s);</span><br><span class="line">            <span class="keyword">switch</span> (expression[i]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    result = operand1 + operand2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    result = operand1 - operand2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    result = operand1 * operand2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span> (operand2 == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Division by zero error\n&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                    &#125;</span><br><span class="line">                    result = operand1 / operand2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Invalid expression\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">            push(&amp;s, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pop(&amp;s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> expression[] = <span class="string">&quot;523*+&quot;</span>; <span class="comment">// 后缀表达式 5 + (2 * 3)</span></span><br><span class="line">    <span class="type">double</span> result = evaluatePostfix(expression);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %.2f\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中缀转前缀"><a href="#中缀转前缀" class="headerlink" title="中缀转前缀"></a>中缀转前缀</h4><p>中缀转前缀的手算方法：</p>
<ol>
<li>确定中缀表达式中各个运算符的运算顺序</li>
<li>选择下一个运算符，按照==[运算符 左操作数 右操作数]==的方式组合成一个新的操作数</li>
<li>如果还有运算符没被处理，继续②</li>
</ol>
<p>用栈实现前缀表达式的计算（机算）：</p>
<ol>
<li>从右往左扫描下一个元素直到处理完所有元素</li>
<li>若扫描到操作数的压入栈中。并返回①，否则执行③</li>
<li>若扫描到运算符，则弹出两个栈顶元素（==先出栈的是左操作数==）执行相应运算，运算结果压回栈顶，回到①</li>
</ol>
<p>==右优先原则==：只要右边的运算符能先计算，就优先算右边的</p>
<h3 id="栈在递归中的应用"><a href="#栈在递归中的应用" class="headerlink" title="栈在递归中的应用"></a>栈在递归中的应用</h3><p>函数调用的特点：最后被调用的函数最先执行结束</p>
<p>函数调用时，需要一个栈存储：</p>
<ul>
<li>调用返回地址</li>
<li>实参</li>
<li>局部变量</li>
</ul>
<h3 id="队列在层次遍历中的应用"><a href="#队列在层次遍历中的应用" class="headerlink" title="队列在层次遍历中的应用"></a>队列在层次遍历中的应用</h3><p>在信息处理中有一大类问题需要逐层或逐行处理。这类问题的解决方法，往往是在处理当前层或当前行时，就对下一层或下一行做预处理。把处理顺序安排好，等到当前层或当前行处理完毕，就可以处理下一层或下一行</p>
<p>层次遍历二叉树过程：</p>
<ol>
<li>根节点入队</li>
<li>若队空，表示所有节点都已处理完毕。则结束遍历，否则重复③操作</li>
<li>队列中第一个节点出队，并访问它。若其有左孩子，则将左孩子入队，若其有右孩子则将右孩子入队，返回②</li>
</ol>
<h3 id="队列在操作系统中的应用"><a href="#队列在操作系统中的应用" class="headerlink" title="队列在操作系统中的应用"></a>队列在操作系统中的应用</h3><p><strong>解决主机与外部设备之间速度不匹配的问题</strong></p>
<p>由于主机输出数据给打印机时的速度比打印机打印数据的速度快。所以要设置一个打印数据缓冲区，主机把要打印输出的数据依次写入这个缓冲区，写满后就暂停输入。打印机就从缓冲区中按照先进先出的原则，依次取出数据并打印。打印完后再向主机发出请求。主机接到请求后再向缓冲区写入打印数据</p>
<p><strong>解决由多用户引起的资源竞争问题</strong></p>
<p>多个进程争抢着使用有限的系统资源时，FCFS(先来先服务)是一种常用策略</p>
<h2 id="数组和特殊矩阵"><a href="#数组和特殊矩阵" class="headerlink" title="数组和特殊矩阵"></a>数组和特殊矩阵</h2><p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/3.4%E6%95%B0%E7%BB%84%E5%92%8C%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5.png" alt="3.4数组和特殊矩阵"></p>
<h3 id="数组的存储结构"><a href="#数组的存储结构" class="headerlink" title="数组的存储结构"></a>数组的存储结构</h3><p>数组是线性表的推广，一维数组可视为一个线性表，二维数组可视为其元素是定长数组的线性表</p>
<p>一维数组存储结构$a[i]$的存储地址：$LOC(a_i) = LOC(a_0) + i * sizeof(Elemtype)$</p>
<p>多维数组有两种映射方式：按行优先和按列优先(M为行数，N为列数)</p>
<p>按行优先：$LOC(a_i,_j) = LOC(a_1,_1) + (i * N + j) * sizeof(Elemtype)$</p>
<p>按列优先：$LOC(a_i,_j) = LOC(a_1,_1) + (j * M + i) * L$</p>
<h3 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h3><p>压缩存储：指为多个值相同的元素值分配一个存储空间，对零元素不分配空间</p>
<ul>
<li><p><strong>对称矩阵</strong></p>
<p>n阶矩阵任意元素$a_i,_j$，都有$a_i,_j = a_j,_i$，称为对称矩阵</p>
<p>若仍采用二维数组存放会浪费几乎一半的空间，因此将其按照==行优先或列优先==存放在一维数组中，只存放上三角区或下三角区元素</p>
</li>
<li><p><strong>下三角矩阵</strong></p>
<p>除了主对角线和下三角区，其余元素都为相同常量的矩阵称为下三角矩阵</p>
</li>
<li><p><strong>上三角矩阵</strong></p>
<p>除了主对角线和上三角区，其余的元素都相等</p>
</li>
<li><p><strong>三对角矩阵</strong></p>
<p>又称带状矩阵，当|i - j| &gt; 1时，有$a_i,_j = 0$</p>
<p>如果有n行，除了第一行和最后一行是2个，其余是三个，因此需要存储3n-2个元素</p>
<p>按照行优先，前i-1行有3(i-1)-1个元素，$a_i,_j$是i行第j-i+2个元素,$a_i,_j$是第2i+j-2个元素</p>
<p><strong>已知数组下标k，如何得到在第几行几列</strong>？</p>
<p>3(i-1)-1 &lt; k + 1 &lt; 3i - 1 ==&gt; (k+2) / 3 &lt; i &lt; (k+2) / 3 +1</p>
<p>k = [(k + 2) / 3 + 1]，向下取整可以得到k所在行</p>
</li>
<li><p><strong>稀疏矩阵</strong></p>
<p>非零元素远远少于矩阵元素的个数</p>
<p>压缩存储策略:</p>
<p>顺序存储——三元组&lt;行，列，值&gt;，把非零元素以三元组形式存储</p>
<p>链式存储——十字链表法</p>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/3.4.2%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5.png" alt="3.4.2稀疏矩阵.png"></p>
</li>
</ul>
<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><p>小题考频：2</p>
<p>大题考频：0</p>
<h2 id="串的定义和实现"><a href="#串的定义和实现" class="headerlink" title="串的定义和实现"></a>串的定义和实现</h2><p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/4.1%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E7%8E%B0.png" alt="1.1串的定义和实现.png"></p>
<p>串是一种特殊的<strong>线性表</strong>，串的实际长度只能小于或等于Maxlen，超过预定义长度的串值会被舍去，称为<strong>截断</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SString</span><br></pre></td></tr></table></figure>

<p>串长有两种表示方式：</p>
<ul>
<li>用一个额外变量length存放串的长度</li>
<li>或者在字符串后面加上一个不计入串长的结束标记字符”\0“</li>
</ul>
<h2 id="串的模式匹配"><a href="#串的模式匹配" class="headerlink" title="串的模式匹配"></a>串的模式匹配</h2><h3 id="简单的模式匹配算法"><a href="#简单的模式匹配算法" class="headerlink" title="简单的模式匹配算法"></a>简单的模式匹配算法</h3><p>字串：主串的一部分，一定存在</p>
<p>模式串：不一定能在主串中找到</p>
<p>朴素模式匹配算法：主串长度为n，模式串长度为m，将主串中所有长度为m的子串依次与模式串对比，直到找到一个完全匹配的子串或所有子串都不匹配为止</p>
<p>最坏时间复杂度：O(nm)</p>
<h3 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h3><p>时间复杂度(m+n)</p>
<p>KMP模式匹配需要解决什么问题: 让主串指针不回退，提高匹配效率</p>
<p>对于模式串T = “abaabc”</p>
<ul>
<li>当第6个元素匹配失败时(此时i=6,j=6)，可令主串指针i不变，模式串指针j=3</li>
<li>当第5个元素匹配失败时(此时i=5,j=5)，可令主串指针i不变，模式串指针j=2</li>
<li>当第4个元素匹配失败时(此时i=4,j=4)，可令主串指针i不变，模式串指针j=2</li>
<li>当第3个元素匹配失败时(此时i=3,j=3)，可令主串指针i不变，模式串指针j=1</li>
<li>当第2个元素匹配失败时(此时i=2,j=2)，可令主串指针i不变，模式串指针j=1</li>
<li>当第1个元素匹配失败时(此时i=1,j=1)，匹配下一个相邻子串，令j=0，i++，j++</li>
</ul>
<p>对应next数组：==不同字符串对应next数组不同==，next[0]无脑写0</p>
<table>
<thead>
<tr>
<th align="center">next[0]</th>
<th align="center">next[1]</th>
<th align="center">next[2]</th>
<th align="center">next[3]</th>
<th align="center">next[4]</th>
<th align="center">next[5]</th>
<th align="center">next[6]</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S,SString T,<span class="type">int</span> next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt; T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || S.ch[i] == T.ch[j])&#123; <span class="comment">//如果j=0表示只有一个字符匹配，i和j加1后继续匹配</span></span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.length)				<span class="comment">//匹配成功，返回首字符的位置</span></span><br><span class="line">        <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>KMP算法的进一步优化</strong></p>
<p>对于模式串T = “abaabc”</p>
<table>
<thead>
<tr>
<th align="center">nextval[0]</th>
<th align="center">nextval[1]</th>
<th align="center">nextval[2]</th>
<th align="center">nextval[3]</th>
<th align="center">nextval[4]</th>
<th align="center">nextval[5]</th>
<th align="center">nextval[6]</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p>nextval数组的算法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt;= T.length; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(T.ch[next[j]] == T.ch[j]) <span class="comment">//例如abaabc，next[3]和next[1]相等</span></span><br><span class="line">        nextval[j] = nextval[next[j]];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        nextval[j] = next[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h1><p>小题考频：34<br>大题考频：10</p>
<p>二叉树是逻辑结构</p>
<p>线索二叉树是物理结构</p>
<h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><ul>
<li>空树：节点数为0的树</li>
<li>非空树的特性：有且仅有一个根节点</li>
<li>叶子节点（终端节点）：没有后继的节点</li>
<li>分支节点（非终端节点）：有后继的节点</li>
<li>祖先节点：当前节点到根节点上所有节点</li>
<li>子孙节点：当前节点下所有后继节点</li>
<li>双亲节点：当前节点的直接前驱节点</li>
<li>孩子节点：当前节点的直接后继节点</li>
<li>兄弟节点：当前节点的直接前驱节点的其余直接后继节点</li>
<li>堂兄弟节点：父亲节点的兄弟节点的孩子节点</li>
<li>路径：两个节点之间的路线，只能从上往下</li>
<li>路径长度：路线经过几条边</li>
<li>节点的层次(深度)：从上往下数第几层</li>
<li>节点的高度：从下往上数</li>
<li>树的高度(深度)：总共多少层</li>
<li>节点的度：当前节点有几个分支(孩子)</li>
<li>树的度：各节点的度的最大值</li>
</ul>
<p>除了根节点外，任何一个节点都<strong>有且仅有一个前驱</strong>，可以有0个或多个后继</p>
<p>其余节点本身又是一棵树，并且称为前驱节点的<strong>子树</strong></p>
<p><strong>有序树</strong>：逻辑上看，树中节点的各子树从左至右是有次序的，不能互换</p>
<p><strong>无序树</strong>：逻辑上看，树中节点的各子树从左至右是无次序的，可以互换</p>
<p><strong>森科</strong>：由m(m&gt;=0)个互不相交的树组成的集合</p>
<p>树的常考性质</p>
<ul>
<li><p>==总节点数 = $n_0+n_1+n2$($n_0,n_1,n_2$分别为度为0,1,2节点的个数)==</p>
</li>
<li><p>叶节点数 = 度为2的节点数 + 1</p>
</li>
<li><p>度为m的树和m叉树的区别：</p>
<p>度为m的树，任意节点的度&lt;=m，至少有一个节点的度为m</p>
<p>m叉树，每个节点最多只能有m个孩子，可以所有节点的度都小于m</p>
</li>
<li><p>度为m的树第i层最多有$m^{i-1}$个节点</p>
</li>
<li><p>高度为h的m叉树最多有$\frac{m^h-1}{m-1}$个节点</p>
</li>
<li><p>高度为h的m叉树至少有h个节点</p>
</li>
<li><p>高度为h，度为m的树至少有h+m-1</p>
</li>
<li><p>具有n个节点的m叉树的最小高度为$\lceil log_m(n(m-1)+1) \rceil$(向上取整)</p>
</li>
</ul>
<h2 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h2><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/5.2.1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89.png" alt="5.2.1二叉树的定义.png"></p>
<p>==二叉树==是n(n≥0)个节点的有限集合：</p>
<ul>
<li>或者为空二叉树，即n=0</li>
<li>或者由一个根节点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li>每个节点至多只有两颗子树</li>
<li>左右子树不能颠倒（==二叉树是有序树==）</li>
</ul>
<p>==满二叉树==：除了叶节点每个节点都有两个孩子节点，高度为h，且含有$2^h-1$个节点的二叉树</p>
<p><strong>特点</strong>：</p>
<ul>
<li>只有最后一层有叶子节点</li>
<li>不存在度为1的节点</li>
<li>按层序从1开始编号，节点i的左孩子为2i，右孩子为2i+1，节点i的父节点为[i/2](向下取整)</li>
</ul>
<p>==完全二叉树==：当且仅当其每个节点都与高度为h的满二叉树中编号为1~n的节点一一对应，称为完全二叉树</p>
<p><strong>特点</strong>：</p>
<ul>
<li>只有最后两层可能有叶子节点</li>
<li>==最多只有一个度为1的节点==</li>
<li>==节点i的左孩子为2i，右孩子为2i+1，节点i如果有父节点的话，父节点为[i/2]==(向下取整)<ul>
<li>i&lt;[n/2]为分支节点，i&gt;[n/2]为叶子节点</li>
</ul>
</li>
<li>2i &lt;= n时节点有左孩子，2i + 1 &lt;= n时节点有右孩子</li>
</ul>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/5.2%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="5.2满二叉树和完全二叉树"></p>
<p>==二叉排序树==：一棵二叉树或者是空二叉树，或者具备以下性质的树</p>
<ul>
<li>左子树上所有节点的关键字均小于根节点的关键字</li>
<li>右子树上所有节点的关键字均大于根节点的关键字</li>
<li>左子树和右子树有各式一棵二叉排序树</li>
</ul>
<p>==平衡二叉树==：树上任一节点的左子树和右子树的深度只差不超过1</p>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="1二叉树的顺序存储"><a href="#1二叉树的顺序存储" class="headerlink" title=".1二叉树的顺序存储"></a>.1二叉树的顺序存储</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElemType value;		<span class="comment">//节点中的数据元素</span></span><br><span class="line">    <span class="type">bool</span> isEmpty;		<span class="comment">//节点是否为空</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义一个长度为MaxSize的数组t，按照从上至下，从左至右的顺序依次存储完全二叉树中的各个节点</span></span><br><span class="line">TreeNode t[MaxSize];	</span><br></pre></td></tr></table></figure>

<p>完全二叉树和满二叉树采用顺序存储比较合适，树中节点的序号可以唯一反应节点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值确定节点在二叉树中的位置</p>
<p>但对于一般二叉树，顺序存储时要把节点的编号和完全二叉树对应起来，这就导致添加了许多不存在的空节点</p>
<h4 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    Elemtype data;					 <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>  *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>   <span class="comment">//左孩子和右孩子指针		</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>

<p>如果需要找到节点的父节点可以在结构体中加入增加指向父节点的指针</p>
<p>n个节点的二叉链表有n+1个空链域</p>
<h2 id="二叉树的遍历和线索二叉树"><a href="#二叉树的遍历和线索二叉树" class="headerlink" title="二叉树的遍历和线索二叉树"></a>二叉树的遍历和线索二叉树</h2><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>在二叉树的前序序列、中序序列和后序序列中，所有叶节点的先后顺序==完全相同==</p>
<h4 id="二叉树的先、中、后序遍历"><a href="#二叉树的先、中、后序遍历" class="headerlink" title="二叉树的先、中、后序遍历"></a>二叉树的先、中、后序遍历</h4><p>遍历一棵二叉树要决定对根节点N、左子树L和右子树R的访问顺序</p>
<ul>
<li>先序遍历(NLR)：根左右</li>
<li>中序遍历(LNR)：左根右</li>
<li>后序遍历(LRN)：左右根</li>
</ul>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/5.3.1.1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.png" alt="5.3.1.1二叉树的遍历"></p>
<p><strong>每个节点都是通过visit(T)访问的，因为每个节点都会被视为一次根节点</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    Elemtype data;					 <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>  *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>   <span class="comment">//左孩子和右孩子指针		</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="comment">// 先序遍历，第一次路过时访问节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="comment">//若当前节点为空什么也不做</span></span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        visit(T);                <span class="comment">// 访问根节点</span></span><br><span class="line">        PreOrder(T-&gt;lchild);     <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild);     <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历，第二次路过时访问节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PreOrder(T-&gt;lchild);     <span class="comment">// 递归遍历左子树</span></span><br><span class="line">		visit(T);                <span class="comment">// 访问根节点</span></span><br><span class="line">        PreOrder(T-&gt;rchild);     <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历，第三次路过时访问节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PreOrder(T-&gt;lchild);     <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild);     <span class="comment">// 递归遍历右子树</span></span><br><span class="line">		visit(T);                <span class="comment">// 访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>遍历算数表达式树</p>
<ul>
<li>先序遍历得前缀表达式</li>
<li>中序遍历得中缀表达式(没有括号)</li>
<li>后序遍历得后缀表达式</li>
</ul>
<h4 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h4><p><strong>二叉树的层序遍历</strong></p>
<p>算法思想</p>
<ul>
<li>初始化一个辅助队列</li>
<li>根节点入队</li>
<li>若队列非空，则队头节点出列，访问该节点，并将其左、右孩子插入队尾(如果有的话)，存指针而不是节点</li>
<li>重复③直到队空</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="type">void</span> 层序遍历(BiTree T) &#123;</span><br><span class="line"></span><br><span class="line">  LinkQueue Q;</span><br><span class="line">  InitQueue(Q);  		<span class="comment">// 初始化辅助队列(链队列)</span></span><br><span class="line">  BiTree p; 	 		<span class="comment">// 声明二叉树节点指针</span></span><br><span class="line">  EnQueue(Q, T); 		<span class="comment">// 将根节点入队</span></span><br><span class="line">  <span class="comment">// 队列不为空时</span></span><br><span class="line">  <span class="keyword">while</span> (!IsEmpty(Q)) &#123;</span><br><span class="line">    DeQueue(Q, p); 		<span class="comment">// 队头节点出队</span></span><br><span class="line">    visit(p);    		<span class="comment">// 访问出队节点</span></span><br><span class="line">    <span class="comment">// 如果左子节点不为空，入队(存指针而不是节点)</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      EnQueue(Q, p-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果右子节点不为空，入队</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      EnQueue(Q, p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h4><p>若只给出一棵二叉树的前、中、后层序遍历序列中的一种，不能唯一确定一棵二叉树</p>
<p><strong>前序 + 中序遍历序列</strong></p>
<p>!s<a target="_blank" rel="noopener" href="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/5.3.1.3%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.png">5.3.1.3中序 + 后序遍历序列</a></p>
<p><strong>后序 + 中序遍历序列</strong></p>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/5.3.1.3%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.png" alt="5.3.1.3中序 + 后序遍历序列"></p>
<p><strong>层序 + 中序遍历序列</strong></p>
<p>层序遍历：DABEFCGHI</p>
<p>中序遍历：E==A==F==D==HC==B==GI(高亮为根节点)</p>
<p><strong>如果不使用中序遍历序列，从前序、后序、层序遍历中选择两个，不能构造唯一的二叉树</strong></p>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><strong>高频考点</strong>：线索化——==手算(最常考)==和代码；==找前驱和后继==</p>
<p>线索二叉树：在普通二叉树节点的基础上，增加两个标志位<code>ltga</code>和<code>rtag</code></p>
<img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/思维导图/5.3.2中序线索二叉树.png" alt="5.3.2中序线索二叉树" style="zoom: 67%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线索二叉树节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag, rtag; <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125; ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure>

<p><strong><code>tag</code> = 0表示指针指向的是孩子</strong></p>
<p><strong><code>tag </code>= 1表示指针指向的是前驱或后继</strong></p>
<p>三种线索二叉树：前序、中序、后序线索二叉树</p>
<h4 id="1线索化二叉树"><a href="#1线索化二叉树" class="headerlink" title=".1线索化二叉树"></a>.1线索化二叉树</h4><p>用土方法找到中序前驱(重新进行一次中序遍历)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">findPre</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PreOrder(T-&gt;lchild);     <span class="comment">// 递归遍历左子树</span></span><br><span class="line">		visit(T);                <span class="comment">// 访问根节点</span></span><br><span class="line">        PreOrder(T-&gt;rchild);     <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BiTNode *p;					<span class="comment">//p指向目标节点(要找到它的前驱)</span></span><br><span class="line">BiTNode *pre = <span class="literal">NULL</span>;		<span class="comment">//pre指向当前访问节点的前驱</span></span><br><span class="line">BiTNode * final = Null;		<span class="comment">//记录p最终的前驱节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(BiTnode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == p)				<span class="comment">//如果重新访问到p</span></span><br><span class="line">        final = pre;		<span class="comment">//找到p的前驱</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre = q;			<span class="comment">//如果没访问到p，就把当前节点作为下一个被访问节点的前驱节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>中序线索化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序线索化二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(T);</span><br><span class="line">        <span class="comment">//重要！！！不要忘记处理最后一个节点的右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        InThread(T-&gt;lchild);     <span class="comment">// 中序遍历左子树</span></span><br><span class="line">		visit(T);                <span class="comment">// 访问根节点</span></span><br><span class="line">        InThread(T-&gt;rchild);     <span class="comment">// 中遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">    <span class="comment">//如果当前节点左孩子为空</span></span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        q-&gt;lchild = pre;		<span class="comment">//建立前驱线索</span></span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;        	<span class="comment">//让左指针变为线索指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果前驱节点不为空，且前驱节点右指针为空</span></span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre-&gt;rchild = q;		<span class="comment">//把前驱节点的后继指针指向当前节点</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;		<span class="comment">//让右指针变为线索指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还要检查最后的pre的rchild是否为NULL，如果是，令rtag=1</p>
<p>先序线索化</p>
<p>当ltag=0时才能对当前节点的左孩子进行访问</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历二叉树并线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreThread</span><span class="params">(Thread Tree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        visit(T);     				<span class="comment">//先处理根节点                                      </span></span><br><span class="line">        <span class="keyword">if</span> (T-&gt;ltag == <span class="number">0</span>)			<span class="comment">//lchild不是前驱线索时，否则会导致访问当前节点的前驱节点</span></span><br><span class="line">            PreThread(T-&gt;lchild);</span><br><span class="line">        PreThread(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>后序线索化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostThread</span><span class="params">(ThreadTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PostThread(T-&gt;lchild);     <span class="comment">// 后序遍历左子树</span></span><br><span class="line">        PostThread(T-&gt;rchild);     <span class="comment">// 后序遍历右子树</span></span><br><span class="line">		visit(T);                <span class="comment">// 访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后序线索化最后处理根节点因此不会出现访问当前节点的前驱节点的情况</p>
<h4 id="在线索二叉树中找前驱和后继"><a href="#在线索二叉树中找前驱和后继" class="headerlink" title="在线索二叉树中找前驱和后继"></a>在线索二叉树中找前驱和后继</h4><p>在中序线索二叉树找到指定节点*p的中序后继next</p>
<ul>
<li>若p-&gt;rtag==1，则next = p-&gt;rchild</li>
<li>若p-&gt;rtag==0，则next = p的右子树最左下节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到p的右子树最左下节点</span></span><br><span class="line">ThreadNode *<span class="title function_">Firstnode</span><span class="params">(ThreadNode *p)</span> &#123;</span><br><span class="line">    <span class="comment">// 循环找到最左下节点(不一定是叶节点)</span></span><br><span class="line">    <span class="keyword">while</span> (p-&gt;ltag == <span class="number">0</span>) </span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在中序线索二叉树中找到节点p的后继节点</span></span><br><span class="line">ThreadNode *<span class="title function_">Nextnode</span><span class="params">(ThreadNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rtag == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> Firstnode(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild; <span class="comment">// rtag==1直接返回后继线索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对中序线索二叉树进行中序遍历(利用线索实现的非递归算法)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Inorder</span><span class="params">(ThreadNode *T)</span>&#123;</span><br><span class="line">    <span class="comment">//令p等于从根出发最左下角的节点(第一个被遍历的节点)，如果p不为空，让p等于当前节点的后继节点</span></span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = Firstnode(T);p!=<span class="literal">NULL</span>;p=Nextnode(p))</span><br><span class="line">        visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在中序线索二叉树找到指定节点*p的中序前驱pre</p>
<ul>
<li>若p-&gt;rtag = 1，则pre = p-&gt;lchild</li>
<li>若p-&gt;rtag = 0，则pre = p的左子树中最右下节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到p的左子树最右下节点</span></span><br><span class="line">ThreadNode *<span class="title function_">Firstnode</span><span class="params">(ThreadNode *p)</span> &#123;</span><br><span class="line">    <span class="comment">// 循环找到最右下节点(不一定是叶节点)</span></span><br><span class="line">    <span class="keyword">while</span> (p-&gt;rtag == <span class="number">0</span>) </span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在中序线索二叉树中找到节点p的后继节点</span></span><br><span class="line">ThreadNode *<span class="title function_">Prenode</span><span class="params">(ThreadNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> Lastnode(p-&gt;lchild);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> p-&gt;lchild; <span class="comment">// ltag==1直接返回前驱线索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对中序线索二叉树进行==逆向==中序遍历</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RevInorder</span><span class="params">(ThreadNode *T)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = Lastnode(T);p!=<span class="literal">NULL</span>;p=Prenode(p))</span><br><span class="line">        visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>先序线索二叉树找先序后继</p>
<ul>
<li>若p-&gt;rtag == 1，则next = p-&gt;rchild</li>
<li>若p-&gt;rtag == 0，右孩子存在则<ul>
<li>左孩子存在：先序后继为左孩子</li>
<li>左孩子不存在：先序后继为右孩子</li>
</ul>
</li>
</ul>
<p>先序线索二叉树找先序前驱</p>
<ul>
<li>若p-&gt;ltag == 1，则pre = p-&gt;lchild</li>
<li>若p-&gt;ltag == 0，则找不到前驱(需要借助父节点)</li>
</ul>
<p>后序线索二叉树找后序前驱</p>
<ul>
<li>若p-&gt;ltag == 1，则pre = p-&gt;lchild</li>
<li>若p-&gt;ltag == 0<ul>
<li>有右孩子，则后序前驱为右孩子</li>
<li>没有右孩子，则后序前驱为左孩子</li>
</ul>
</li>
</ul>
<p>后序线索二叉树找后序后继</p>
<ul>
<li>若p-&gt;rtag == 1，则next = p-&gt;rchild</li>
<li>若p-&gt;rtag == 0，则找不到后继</li>
</ul>
<h2 id="树、森林"><a href="#树、森林" class="headerlink" title="树、森林"></a>树、森林</h2><p>树的逻辑结构</p>
<p>树是n(n&gt;=0)个节点阿有限集合，n=0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：</p>
<ul>
<li>有且仅有一个特定的称为根的节点</li>
<li>当n&gt;1时，其余节点可分为m(m&gt;0)个互不相交的有限集合$T_1,T_2,T_3,…,T_n$，其中每个集合本身又是一棵树，并且称为根节点的子树</li>
</ul>
<h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><h4 id="双亲表示法-顺序存储"><a href="#双亲表示法-顺序存储" class="headerlink" title="双亲表示法(顺序存储)"></a>双亲表示法(顺序存储)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[A] --&gt; B[B]</span><br><span class="line">A --&gt; C[C]</span><br><span class="line">A --&gt; D[D]</span><br><span class="line">B --&gt; E[E]</span><br><span class="line">B --&gt; F[F]</span><br><span class="line">C --&gt; G[G]</span><br><span class="line">D --&gt; H[H]</span><br><span class="line">D --&gt; I[I]</span><br><span class="line">D --&gt; J[J]</span><br><span class="line">E --&gt; K[K]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>思路：用数组顺序存储各个节点，每个节点中保存数据元素、指向双亲节点(父节点)的“指针”</p>
<table>
<thead>
<tr>
<th></th>
<th align="center">data</th>
<th align="center">parent</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td align="center">A</td>
<td align="center">-1</td>
</tr>
<tr>
<td>1</td>
<td align="center">B</td>
<td align="center">0</td>
</tr>
<tr>
<td>2</td>
<td align="center">C</td>
<td align="center">0</td>
</tr>
<tr>
<td>3</td>
<td align="center">D</td>
<td align="center">0</td>
</tr>
<tr>
<td>4</td>
<td align="center">E</td>
<td align="center">1</td>
</tr>
<tr>
<td>5</td>
<td align="center">F</td>
<td align="center">1</td>
</tr>
<tr>
<td>6</td>
<td align="center">G</td>
<td align="center">2</td>
</tr>
<tr>
<td>7</td>
<td align="center">H</td>
<td align="center">3</td>
</tr>
<tr>
<td>8</td>
<td align="center">I</td>
<td align="center">3</td>
</tr>
<tr>
<td>9</td>
<td align="center">J</td>
<td align="center">3</td>
</tr>
<tr>
<td>10</td>
<td align="center">K</td>
<td align="center">4</td>
</tr>
<tr>
<td>11</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>12</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;  <span class="comment">// 数据元素</span></span><br><span class="line">    <span class="type">int</span> parent;     <span class="comment">// 双亲位置域</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];    <span class="comment">// 双亲表示法定义的树</span></span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">// 结点数</span></span><br><span class="line">&#125; PTree;</span><br></pre></td></tr></table></figure>

<p><strong>双亲表示法也可以用来存储森林</strong>，把每个树的根节点设为-1</p>
<p>双亲表示法的优缺点</p>
<ul>
<li>优点：可以快速找到父节点</li>
<li>缺点：找孩子不方便，只能从头到尾遍历整个数组</li>
<li>应用场景：找父亲多，找孩子少，如并查集</li>
</ul>
<h4 id="孩子表示法-顺序-链式存储"><a href="#孩子表示法-顺序-链式存储" class="headerlink" title="孩子表示法(顺序+链式存储)"></a>孩子表示法(顺序+链式存储)</h4><p>孩子表示法：用数组顺序存储各个节点，每个节点中保存数据元素孩子链表头指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> child; <span class="comment">// 孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span> <span class="comment">// 下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span> <span class="comment">// 第一个孩子</span></span><br><span class="line">&#125; CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n, r; <span class="comment">// 记录结点数和记录根的位置</span></span><br><span class="line">&#125; CTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以用孩子表示法存储<strong>森林</strong>，需要记录多个根的位置</p>
<p>孩子表示法优缺点</p>
<ul>
<li>优点：找孩子方便</li>
<li>缺点：找双亲不方便，只能遍历每个链表</li>
<li>应用场景：服务流程树，适用于找孩子多，找父亲少</li>
</ul>
<h4 id="孩子兄弟表示法-链式存储"><a href="#孩子兄弟表示法-链式存储" class="headerlink" title="孩子兄弟表示法(链式存储)"></a>孩子兄弟表示法(链式存储)</h4><p>左针指向第一个孩子(从左至右)，右指针指向第一个右兄弟</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义结构体CSNode，表示树的节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> &#123;</span></span><br><span class="line">    ElemType data;              <span class="comment">// 数据域，存储节点的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>;</span>  <span class="comment">// 指向第一个孩子的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">nextsibling</span>;</span> <span class="comment">// 指向右兄弟的指针</span></span><br><span class="line">&#125; CSNode, *CSTree;              </span><br></pre></td></tr></table></figure>

<p>可以用孩子兄弟表示法存储森林，把各个树的根视为同一层的兄弟</p>
<p>从存储视角来看形态上和二叉树类似</p>
<h3 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h3><p>使用孩子兄弟表示法转换</p>
<h4 id="树转二叉树"><a href="#树转二叉树" class="headerlink" title="树转二叉树"></a>树转二叉树</h4><p>树→二叉树转换技巧</p>
<ul>
<li><p>先在二叉树中，画一个根节点</p>
</li>
<li><p>按==树的层序==依次处理每个节点</p>
<p>处理一个节点的方法是：如果当前处理的节点在树中有孩子，就把所有<strong>孩子结点</strong>用==右指针==串成一串，并在二叉树中把第一个孩子挂在当前节点的左指针下面</p>
</li>
</ul>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/5.4.2.1%E6%A0%91%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="5.4.2.1树转二叉树.png"></p>
<h4 id="森林转二叉树"><a href="#森林转二叉树" class="headerlink" title="森林转二叉树"></a>森林转二叉树</h4><p>森林→二叉树转换技巧</p>
<ul>
<li>先把所有树的根节点画出来，在二叉树中用右指针串成糖葫芦</li>
<li>按森林的层序依次处理每个节点</li>
</ul>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/5.4.2.2%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="5.4.2.2森林 转 二叉树"></p>
<h4 id="二叉树转树"><a href="#二叉树转树" class="headerlink" title="二叉树转树"></a>二叉树转树</h4><p> 二叉树→树转换技巧</p>
<ul>
<li><p>先画出树的根节点</p>
</li>
<li><p>从树的根节点开始，按“树的层序”恢复每个结点的孩子</p>
<p>如何恢复一个节点的孩子，在二叉树中，如果当前处理的节点有左孩子，就把左孩子和一整串右指针糖葫芦拆下来，按顺序挂在当前节点的下方</p>
</li>
</ul>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/5.4.2.3%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%A0%91.png" alt="5.4.2.3二叉树 转 树"></p>
<h4 id="二叉树转森林"><a href="#二叉树转森林" class="headerlink" title="二叉树转森林"></a>二叉树转森林</h4><p>二叉树森林转换技巧:</p>
<ul>
<li><p>先把二叉树的根节点和一整串右指针糖葫芦拆下来，作为多棵树的根节点 </p>
</li>
<li><p>按“森林的层序”恢复每个结点的孩子</p>
<p>如何恢复一个结点的孩子：在二叉树中，如果当前处理的结点有左孩子，就把左孩子和“一整串右指针糖葫 芦”拆下来，按顺序挂在当前结点的下方</p>
</li>
</ul>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/5.4.2.4%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%A3%AE%E6%9E%97.png" alt="5.4.2.4二叉树 转 森林"></p>
<h3 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h3><p><strong>树的先根遍历</strong>——深度优先遍历：若树非空，先访问根节点，再依次对每棵子树进行先根遍历</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[A] --&gt; B[B]</span><br><span class="line">A --&gt; C[C]</span><br><span class="line">A --&gt; D[D]</span><br><span class="line">B --&gt; E[E]</span><br><span class="line">B --&gt; F[F]</span><br><span class="line">C --&gt; G[G]</span><br><span class="line">D --&gt; H[H]</span><br><span class="line">D --&gt; I[I]</span><br><span class="line">D --&gt; J[J]</span><br><span class="line">E --&gt; K[K]</span><br></pre></td></tr></table></figure>

<p>遍历顺序：A  ( B ( E K ) F )  ( C G )  ( D H I J )</p>
<p>树的先根遍历序列与这棵树<strong>对应二叉树的先序序列</strong>相同</p>
<p><strong>树的后根遍历</strong>——深度优先遍历：若树非空，先依次对每个子树进行后根遍历，最后再访问根结点</p>
<p>遍历顺序：( (K E ) F B)  (G C)  (H I J D)  A</p>
<p>树的后根遍历序列与这棵树对应二叉树的<strong>中序序列</strong>相同</p>
<p>**树的层次遍历(用队列实现)**——广度优先遍历</p>
<ul>
<li>若树非空，则根结点入队</li>
<li>若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队</li>
<li>重复②直到队空</li>
</ul>
<p>遍历顺序：ABCDEFGHIJK</p>
<p><strong>先序遍历森林</strong>： 若森林非空，则按如下规则进行遍历</p>
<p>效果等同于依次对各个树进行先根遍历的结果以及对森林对应二叉树进行的==先序遍历==</p>
<ul>
<li>我们森林中第一棵树的根节点</li>
<li>先序遍历的一棵树中根节点的子树森林</li>
<li>先序遍历除去第一棵树之后剩下树构成的森林</li>
</ul>
<p><strong>中序遍历森林</strong>：则按如下规则进行遍历</p>
<p>效果上等同于依次对各个树进行后根遍历和对森林对应二叉树的进行==中序排列==</p>
<ul>
<li>中序遍历森林中第一棵树的根节点的子树森林</li>
<li>访问第一棵树的根节点</li>
<li>中序遍历除去第一棵树之后剩余的树构成的森林</li>
</ul>
<h2 id="树与二叉树的应用"><a href="#树与二叉树的应用" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h2><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p><strong>哈夫曼树的定义</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[1] --&gt; B[1]</span><br><span class="line">A[1] --&gt; C[4]</span><br><span class="line">B[1] --&gt; E[2]</span><br><span class="line">B[1] --&gt; F[1]</span><br><span class="line">F[1] --&gt; G[5]</span><br><span class="line">F[1] --&gt; H[1]</span><br><span class="line">E[2] --&gt; I[10]</span><br><span class="line">E[2] --&gt; J[3]</span><br></pre></td></tr></table></figure>



<p>结点的==权==：有某种现实含义的数值(如:表示结点的重要性等)<br>==结点的带权路径长度==：从树的根到该结点的路径长度(经过的边数)与该结点上权值的乘积</p>
<p>节点3的带权路径长度 = 3(路径长度) * 3(节点的权)</p>
<p>节点4的带权路径长度 = 1 * 4</p>
<p>树的带权路径长度：树中所有==叶结点==的带权路径长度之和(WPL, Weighted Path Length)<br>$$<br>\text{WPL} = \sum_{i=1}^n w_i l_i<br>$$<br>在含有n个带权叶结点组成的二叉树中，其中带权路径长度(WPL)最小的二叉树称为==哈夫曼树==，也称最优二叉树</p>
<p><strong>哈夫曼树的构造</strong></p>
<p>给定个权值分别为W1,W2,…, w的结点,构造哈夫曼树的算法描述如下:</p>
<ul>
<li>将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F</li>
<li>构造一个新结点,从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新 结点的权值置为左、右子树上根结点的权值之和</li>
<li>从F中删除刚才选出的两棵树,同时将新得到的树加入F中</li>
<li>重复步骤②和③，直至F中只剩下一棵树为止</li>
</ul>
<p><strong>哈夫曼树的性质</strong></p>
<ul>
<li>每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大</li>
<li>哈夫曼树的结点总数为2n-1，n个初始结点需要合并n-1次，每次产生一个新的结点，总共是n + n - 1 = 2n - 1个</li>
<li>哈夫曼树中不存在度为1的结点</li>
<li>哈夫曼树并不唯一，但WPL必然相同且为最优</li>
<li>哈夫曼树的带权路径长度等于树中所有==叶结点==的带权路径长度之和或者<strong>所有分支结点的权值之和</strong></li>
</ul>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/5.5.1%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0.png" alt="5.5.1哈夫曼树的构造"></p>
<p><strong>哈夫曼编码</strong></p>
<p>固定长度编码：在数据通信中，若对每个字符用相等长度的二进制位表示，称这种编码方式为固定长度编码</p>
<p>可变长度编码：如允许对不同字符用不等长的二进制位表示，则这种编码方式称为可变长度编码</p>
<p>前缀编码：若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。举例：设计字符A，B和C对应的编码为0，10，110是前缀编码，对前缀编码的解码很简单不会出现歧义如0010110就是AABC，如果出现D编码为11则无法翻译编码</p>
<p>A——00<br>B——01<br>C——10<br>D——11<br>假设100题中有80题选C，10题选A，8题选B，2题选D，所有答案的二进制长度=80*2+10*2+8*2+2*2=200 bit</p>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/5.5.1%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%911.png" alt="5.5.1哈夫曼树1png"></p>
<p><strong>用哈夫曼树进行编码</strong></p>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/5.5.1%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%912.png" alt="5.5.1哈夫曼树2"></p>
<p>哈夫曼树编码：字符集中的每个字符作为一个==叶子节点==，各个字符出现的频度作为节点的权值，对叶子结点进行构造哈夫曼树，哈夫曼树不唯一，因此哈夫曼编码不唯一</p>
<p>哈夫曼编码只对==叶子结点==进行编码</p>
<p><strong>哈夫曼树的应用</strong>：数据的压缩</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集是一种简单的==集合==表示，它支持以下三种操作</p>
<ul>
<li>Initial (S)：将集合S中的每个元素都初始化为只有一个单元素的子集合</li>
<li>Union (S, Root1, Root2)：把集合中的子集合 Root2并入子集合 Root1，要求 Root1 和Root2 互不相交,否则不执行合并</li>
<li>Find (S,x)：查找集合中单元素x所在的子集合,并返回该子集合的根结点</li>
</ul>
<p>通常用树的==双亲表示法==作为并查集的存储结构，每个子集合用一棵树表示，构成表示全集合的森林。</p>
<p>并：使用双亲表示法可以很方便的进行合并操作，只需要把根节点的parent元素改为另一个树的根节点</p>
<p>查：从当前结点出发，根据parent元素一路往上查就能找到根节点，可以用来判断两个结点是否属于同一个集合</p>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/5.5.2%E5%B9%B6%E6%9F%A5%E9%9B%86.png" alt="image-20240506170112107"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="type">int</span> UFSets[SIZE];		<span class="comment">//并查集合元素数组(双亲指针数组)</span></span><br><span class="line"><span class="comment">//并查集初始化操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Initial</span><span class="params">(<span class="type">int</span> S[])</span>&#123;	<span class="comment">//S为并查集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; SIZE; i++)</span><br><span class="line">        S[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并查集的find操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)		<span class="comment">//循环寻找x的根节点，根的S[]小于0</span></span><br><span class="line">        x=S[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并查集的Union操作，Root：集合根节点的数组下标</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1,<span class="type">int</span> Root2)</span>&#123;</span><br><span class="line">    <span class="comment">//要求Root1和Root2是不同集合</span></span><br><span class="line">    <span class="keyword">if</span>(Root1 == Root2)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//将根Root2连接到另一根Root1下面</span></span><br><span class="line">    S[Root2] = Root1</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>操作优化</p>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/5.5.2%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%93%8D%E4%BD%9C%E4%BC%98%E5%8C%96.png" alt="image-20240506170604434"></p>
<p><strong>Union操作优化</strong></p>
<p>Find操作的时间复杂度和树的高度有关，因此优化思路为Union操作时尽量不让树长的高</p>
<ul>
<li><p>用根节点的绝对值表示树的结点总数</p>
<p>例如A树中有6个结点，该树根节点的S[]为<code>-6</code></p>
</li>
<li><p>Union操作，让小树合并到大树</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Union操作，小树合并到大树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> Root1, <span class="type">int</span> Root2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Root1 == Root2) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (S[Root2] &gt; S[Root1]) &#123; <span class="comment">// Root2结点数更少</span></span><br><span class="line">        S[Root1] += S[Root2]; <span class="comment">// 累加结点总数</span></span><br><span class="line">        S[Root2] = Root1; <span class="comment">// 小树合并到大树</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        S[Root2] += S[Root1]; <span class="comment">// 累加结点总数</span></span><br><span class="line">        S[Root1] = Root2; <span class="comment">// 小树合并到大树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法构造的树高不超过==$[log_2n]+1$==，后续Find操作时间复杂度也是O($log_2n$)</p>
<p><strong>Find操作优化</strong></p>
<p>压缩路径——Find操作，先找到根节点，再将查找路径上所有节点都挂到根节点下，这样下一次查找该节点时，一次就能找根节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find操作优化，先找到根节点，再进行压缩路径</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> root = x;</span><br><span class="line">    <span class="keyword">while</span> (S[root] &gt;= <span class="number">0</span>) </span><br><span class="line">        root = S[root]; <span class="comment">// 循环找到根</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩路径</span></span><br><span class="line">    <span class="keyword">while</span> (x != root) &#123;</span><br><span class="line">        <span class="type">int</span> t = S[x]; <span class="comment">// t指向x的父节点</span></span><br><span class="line">        S[x] = root; <span class="comment">// x直接挂到根节点下</span></span><br><span class="line">        x = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回根节点编号</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次Find操作，先找根，再“压缩路径”，可使树的高度不超过O(a(n)。a(n)是一个增长很缓慢的函数，对于常见的n值，通常a(n)≤4，因此优化后并查集的Find、Union操作时间开销都很低</p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>小题考频：35<br>大题考频：11</p>
<h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.1%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png" alt="6.1图的基本概念"></p>
<p><strong>图的定义</strong>：图G由顶点集V和边集E组成，记为G = (V, E)，用|V|表示图G中顶点的个数，也称<strong>图G的阶</strong>，用|E|表示图G中边的条数，<strong>图不可以是空</strong>，即V一定是非空集，但E可以是空集</p>
<ul>
<li><p>若E是无向边（简称边）的有限集合时，则图G为==无向图==(例如微信好友关系)</p>
<p>边是顶点的无序对，记为(v, w)或(w, v)，因为(v, w) = (w, v)</p>
<p><strong>G2 = (V2, E2)</strong></p>
<p><strong>V2 = {A, B, C, D, E}</strong></p>
<p><strong>E2 = {(A, B), (B, D), (B, E), (C, D), (C, E), (D, E)}</strong></p>
</li>
<li><p>若E是有向边（也称弧）的有限集合时，则图G为==有向图==(微博关注)</p>
<p>弧是顶点的有序对，记为&lt;v, w&gt;，其中v、w是顶点，v称为弧尾，w称为弧头</p>
<p>&lt;v, w&gt;称为从顶点v到顶点w的弧，也称v邻接到w，或w邻接自v， &lt;v, w&gt; ≠ &lt;w, v&gt;</p>
<p><strong>G1 = (V1, E1)</strong><br><strong>V1 = {A, B, C, D, E}</strong><br><strong>E1 = {&lt;A, B&gt;, &lt;A, C&gt;, &lt;A, D&gt;, &lt;A, E&gt;, &lt;B, A&gt;, &lt;B, C&gt;, &lt;B, E&gt;, &lt;C, D&gt;}</strong></p>
</li>
</ul>
<img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/思维导图/6.1无向图.png" alt="6.1无向图" style="zoom: 50%;" />



<img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/思维导图/6.1有向图.png" alt="6.1有向图" style="zoom:50%;" />



<p><strong>简单图和多重图</strong></p>
<ul>
<li><p>简单图(<strong>数据结构课程只讨论简单图</strong>)</p>
<ul>
<li>不存在重复边</li>
<li>不存在顶点到自身的边</li>
</ul>
</li>
<li><p>多重图</p>
<p>图G中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联，则G为多重图</p>
</li>
</ul>
<p><strong>顶点的度、入度和出度</strong></p>
<ul>
<li>对于无向图：顶点v的度是指依附于该顶点的边的条数，记为TD(v)</li>
<li>对于有向图：<ul>
<li><strong>入度</strong>是以顶点v为终点的有向边的数目，记为ID(v)</li>
<li><strong>出度</strong>是以顶点v为起点的有向边的数目，记为OD(v)</li>
<li>顶点v的度等于其入度和出度之和，即TD(v) = ID(v) + OD(v)</li>
</ul>
</li>
</ul>
<p><strong>顶点-顶点的关系描述</strong></p>
<ul>
<li>路径——顶点A到顶点E之间的一条路径是指顶点序列 ，无向图可以从通过任意方向的边到目标顶点，有向图只能根据箭头方向</li>
<li>回路——第一个顶点和最后一个顶点相同的路径称为回路或环，从顶点A到顶点A的路径</li>
<li>简单路径——在路径序列中，顶点不重复出现的路径称为简单路径</li>
<li>简单回路——除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路</li>
<li>路径长度——路径上边的数目</li>
<li>点到点的距离——从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离<br>若从u到v根本不存在路径，则记该距离为无穷(∞)</li>
<li>无向图中，若从顶点v到顶点w有路径存在，则称v和w是<strong>连通</strong>的</li>
<li>有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是<strong>强连通</strong>的</li>
</ul>
<p><strong>连通图和强连通图</strong></p>
<ul>
<li><p>无向图G中任意两个顶点都是连通的，则称图G为<strong>连通图</strong>，否则称为非连通图</p>
<p>若G是连通图，则最少有 n-1 条边<br>若G是非连通图，则最多可能有$C_{n-1}^2$条边</p>
</li>
<li><p>有向图中任何一对顶点都是强连通的，则称此图为<strong>强连通图</strong></p>
<p>对于n个顶点的有向图G，若G是强连通图，则<strong>最少有 n 条边</strong>(形成回路)</p>
</li>
</ul>
<p><strong>子图</strong></p>
<ul>
<li><p>设有两个图G = (V, E)和G1 = (V1, E1)，若V1是V的子集，且E1是E的子集，则称G1是G的<strong>子图</strong></p>
<p>边的两端必须存在顶点才能构成子图</p>
</li>
<li><p>若有满足V(G1) = V(G)的子图G1，则称其为G的生成子图，即G1的顶点集和G相同</p>
</li>
</ul>
<p><strong>连通分量和强连通分量</strong></p>
<ul>
<li><p>无向图中的==极大连通子图==称为无向图的连通分量</p>
<p><strong>极大连通子图</strong>：子图必须连通，且包含尽可能多的顶点和边</p>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.1%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.png" alt="6.1连通分量"></p>
</li>
<li><p>有向图中的极大强连通子图称为有向图的<strong>强连通分量</strong></p>
<p><strong>极大强连通子图</strong>：子图必须强连通，同时保留尽可能多的边</p>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.1%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.png" alt="6.1强连通分量"></p>
</li>
</ul>
<p><strong>生成树</strong></p>
<p><strong>连通图</strong>的<strong>生成树</strong>是包含图中全部顶点的一个<strong>极小连通子图</strong>，<strong>边尽可能的少</strong>，但要<strong>保持连通</strong></p>
<p>顶点数为n，若G是连通图，则最少有 n-1 条边，即它的生成树含有 n-1 条边</p>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.1%E7%94%9F%E6%88%90%E6%A0%91.png" alt="6.1生成树"></p>
<p><strong>生成森林</strong></p>
<p>在非连通图中，连通分量(极大连通子图)的生成树构成了非连通图的生成森林</p>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.1%E7%94%9F%E6%88%90%E6%A3%AE%E6%9E%97.png" alt="6.1生成森林"></p>
<p><strong>边的权、带权图/网</strong></p>
<ul>
<li>边的权——在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值</li>
<li>带权图/网——边上带有权值的图称为带权图，也称网</li>
<li>带权路径长度——当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度</li>
</ul>
<p><strong>特殊形态的图</strong></p>
<ul>
<li>无向完全图——无向图中任意两个顶点之间都存在边，若无向图的顶点数|V|=n，则|E|= $C_n^2$</li>
<li>有向完全图——有向图中任意两个顶点之间都存在方向相反的两条弧，若有向图的顶点数|V|=n，则|E| = 2$C_n^2$</li>
<li>稀疏图：边数很少的图</li>
<li>稠密图：边数很多的图</li>
<li>树：不存在<strong>回路</strong>，且连通的<strong>无向图</strong>，n个顶点的树，必有n-1条边</li>
<li>有向树：一个顶点的入度为0、其余顶点的入度均为1的<strong>有向图</strong>，称为有向树，有向树不是强连通图</li>
</ul>
<h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.2%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8.png" alt="6.2图的存储"></p>
<h3 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h3><p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.2.1%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95.png" alt="6.2.1邻接矩阵法"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100		<span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> Vex[MaxVertexNum];     <span class="comment">// 顶点表，用于存储顶点信息</span></span><br><span class="line">    <span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum];  <span class="comment">// 邻接矩阵，用于表示顶点之是否存在边/弧</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;         <span class="comment">// 图的当前顶点数和边数/弧数</span></span><br><span class="line">&#125; MGraph; <span class="comment">// 图的数据结构</span></span><br></pre></td></tr></table></figure>

<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.2.1%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95%E5%AD%98%E5%82%A8%E5%B8%A6%E6%9D%83%E5%9B%BE.png" alt="6.2.1邻接矩阵法存储带权图"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 最大int值  <span class="comment">// 表示最大的 int 值，即无穷大</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;  <span class="comment">// 顶点的数据类型，这里是字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;     <span class="comment">// 带权图中边上权值的数据类型，这里是整型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VertexType Vex[MaxVertexNum];   <span class="comment">// 顶点表，用于存储顶点信息</span></span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum];  <span class="comment">// 邻接矩阵，用于表示顶点之间的关系，Edge[i][j]表示顶点 i 和 j 之间的边的权值</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;   <span class="comment">// 图的当前顶点数和边数/弧数</span></span><br><span class="line">&#125; MGraph;  <span class="comment">// 图的数据结构</span></span><br></pre></td></tr></table></figure>

<p>空间复杂度：O(|V|2) ——只和顶点数相关，和实际的边数无关</p>
<p>邻接矩阵法适合用于<strong>存储稠密图</strong> </p>
<p>无向图的邻接矩阵是<strong>对称矩阵</strong>，可以<strong>压缩存储</strong>（只存储上三角区/下三角区）</p>
<p><strong>邻接矩阵法的性质</strong>：设图G的邻接矩阵为<strong>A</strong>（矩阵元素为0/1），则$A^n$的元素$A^n$[i][j]等于由顶点i到顶点j的长度为n的路径的数目</p>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.2.1%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E6%80%A7%E8%B4%A8.png" alt="6.2.1邻接矩阵的性质"></p>
<p>$A^2[1][4] = 1$表示从A到D如果路径长度为2的话，只能找到一条路径，$a_1,_3$表示从A到C的路径，$a_3,_4$表示从C到D</p>
<p>$A^2$矩阵表示对应点之间路径有多少条例如从B到B有三条路径</p>
<h3 id="邻接表法-顺序-链式存储"><a href="#邻接表法-顺序-链式存储" class="headerlink" title="邻接表法(顺序+链式存储)"></a>邻接表法(顺序+链式存储)</h3><p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.2.2%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95.png" alt="6.2.2邻接表法"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 999999</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义顶点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义边的权值的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义被指向的边结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> adjvex;           <span class="comment">// 边指向的顶点在数组中的下标</span></span><br><span class="line">    EdgeType info;        <span class="comment">// 边权值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一条边的指针</span></span><br><span class="line">&#125; ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义顶点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> &#123;</span></span><br><span class="line">    VertexType data;      <span class="comment">// 顶点信息</span></span><br><span class="line">    ArcNode *first;       <span class="comment">// 指向第一条边的指针</span></span><br><span class="line">&#125; VNode, AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义图的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    AdjList vertices;     <span class="comment">// 邻接表数组，存储图的所有顶点的链表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;   <span class="comment">// 顶点数和边数</span></span><br><span class="line">&#125; ALGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个空的邻接表表示的图</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitGraph</span><span class="params">(ALGraph *G)</span> &#123;</span><br><span class="line">    G-&gt;vexnum = <span class="number">6</span>;</span><br><span class="line">    G-&gt;arcnum = <span class="number">9</span>;</span><br><span class="line">    <span class="comment">// 初始化每个顶点的链表为空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; ++i) &#123;</span><br><span class="line">        G-&gt;vertices[i].data = <span class="string">&#x27;A&#x27;</span> + i; <span class="comment">// 假设顶点按照字母顺序排列</span></span><br><span class="line">        G-&gt;vertices[i].first = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边到邻接表中，start是要添加边的起始顶点(例如A)在顶点数组中的索引位置。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AddEdge</span><span class="params">(ALGraph *G, <span class="type">int</span> start, <span class="type">int</span> end, EdgeType weight)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个新的边结点</span></span><br><span class="line">    ArcNode *newArc = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">    newArc-&gt;adjvex = end;		<span class="comment">//边结点指向结点的数组下标</span></span><br><span class="line">    newArc-&gt;info = weight;		<span class="comment">//定义边权值</span></span><br><span class="line">    newArc-&gt;next = G-&gt;vertices[start].first;<span class="comment">//新的被指向结点的next指向上一个被起始顶点指向的结点</span></span><br><span class="line">    G-&gt;vertices[start].first = newArc;<span class="comment">//起始顶点(例如A)的第一条边指向新添加的边结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于是无向图，还需要添加一条从end到start的边</span></span><br><span class="line">    newArc = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">    newArc-&gt;adjvex = start;</span><br><span class="line">    newArc-&gt;info = weight;</span><br><span class="line">    newArc-&gt;next = G-&gt;vertices[end].first;</span><br><span class="line">    G-&gt;vertices[end].first = newArc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    ALGraph G;</span><br><span class="line">    InitGraph(&amp;G);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边</span></span><br><span class="line">    AddEdge(&amp;G, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    AddEdge(&amp;G, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">    AddEdge(&amp;G, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    AddEdge(&amp;G, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">    AddEdge(&amp;G, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">    AddEdge(&amp;G, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">    AddEdge(&amp;G, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="variable">A</span> <span class="operator">---</span> <span class="variable">B</span> <span class="operator">---</span> <span class="built_in">C</span></span><br><span class="line"><span class="operator">|</span>     <span class="operator">|</span>     <span class="operator">|</span></span><br><span class="line"><span class="built_in">D</span> <span class="operator">---</span> <span class="built_in">E</span> <span class="operator">---</span> <span class="variable">F</span></span><br></pre></td></tr></table></figure>

<h3 id="十字链表-链式存储有向图"><a href="#十字链表-链式存储有向图" class="headerlink" title="十字链表(链式存储有向图)"></a>十字链表(链式存储有向图)</h3><p><strong>一般不考代码</strong></p>
<p><strong>弧结点：</strong></p>
<table>
<thead>
<tr>
<th align="center">tailvex(弧尾顶点编号)</th>
<th align="center">headvex(弧头顶点编号)</th>
<th align="center">info</th>
<th align="center">hlink(弧头相同的下条弧)</th>
<th align="center">tlink(弧尾相同的下条弧)</th>
</tr>
</thead>
</table>
<p><strong>顶点结点：</strong></p>
<table>
<thead>
<tr>
<th align="center">data(数据域)</th>
<th align="center">firstin(该顶点作为弧头的第一条弧)</th>
<th align="center">firstout(该顶点作为弧尾的第一条弧)</th>
</tr>
</thead>
</table>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.2.3%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8(%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E6%9C%89%E5%90%91%E5%9B%BE).png" alt="6.2.3十字链表(链式存储有向图)"></p>
<p>弧头：箭头的头</p>
<p>空间复杂度：O(|V|+|E|)</p>
<p>如何找到指定顶点的所有出边？——顺着绿色线路找 </p>
<p>如何找到指定顶点的所有入边？——顺着橙色线路找</p>
<p><strong>十字链表只用于存储有向图</strong></p>
<h3 id="邻接多重表存储无向图"><a href="#邻接多重表存储无向图" class="headerlink" title="邻接多重表存储无向图"></a>邻接多重表存储无向图</h3><p><strong>一般不考代码</strong></p>
<p><strong>边结点</strong>：</p>
<table>
<thead>
<tr>
<th align="center">i(i和j是边的两个顶点编号)</th>
<th align="center">j</th>
<th align="center">info</th>
<th align="center">iLink(依附于顶点i的下一条边)</th>
<th align="center">jLink(依附于顶点j的下一条边)</th>
</tr>
</thead>
</table>
<p><strong>顶点结点</strong>：</p>
<table>
<thead>
<tr>
<th align="center">data(数据域)</th>
<th align="center">firstedge(与该顶点相连的第一条边)</th>
</tr>
</thead>
</table>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.2.4%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E5%AD%98%E5%82%A8%E6%97%A0%E5%90%91%E5%9B%BE.png" alt="6.2.4邻接多重表存储无向图"></p>
<p>删除A和B之间的边以后</p>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.2.4%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E5%AD%98%E5%82%A8%E6%97%A0%E5%90%91%E5%9B%BE%E5%88%A0%E9%99%A4%E8%BE%B9.png" alt="6.2.4邻接多重表存储无向图删除边"></p>
<p>空间复杂度：O(|V|+|E|) </p>
<p>删除边、删除节点等操作很方便 </p>
<p><strong>邻接多重表只适用于存储无向图</strong></p>
<h3 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h3><p>基于邻接矩阵和邻接表实现</p>
<ul>
<li>Adjacent(G, x, y)：判断图G是否存在边&lt;x, y&gt;或(x, y)</li>
<li>Neighbors(G, x)：列出图G中与结点x邻接的边</li>
<li>InsertVertex(G, x)：在图G中插入顶点x</li>
<li>DeleteVertex(G, x)：从图G中删除顶点x</li>
<li>AddEdge(G, x, y)：若无向边(x, y)或有向边&lt;x, y&gt;不存在，则向图G中添加该边</li>
<li>RemoveEdge(G, x, y)：若无向边(x, y)或有向边&lt;x, y&gt;存在，则从图G中删除该边</li>
<li>==FirstNeighbor(G, x)==：求图G中顶点x的第一个邻接点，若有则返回顶点号，若x没有邻接点或图中不存在x，则返回-1</li>
<li>==NextNeighbor(G, x, y)==：假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1</li>
<li>Get_edge_value(G, x, y)：获取图G中边(x, y)或&lt;x, y&gt;对应的权值</li>
<li>Set_edge_value(G, x, y, v)：设置图G中边(x, y)或&lt;x, y&gt;对应的权值为v</li>
</ul>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="图的广度优先遍历——BFS"><a href="#图的广度优先遍历——BFS" class="headerlink" title="图的广度优先遍历——BFS"></a>图的广度优先遍历——BFS</h3><p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.3.1%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" alt="6.3.1图的广度优先遍历思维导图"></p>
<p><strong>广度优先遍历</strong>（Breadth-First-Search, <strong>BFS</strong>） </p>
<ol>
<li>指定一个顶点</li>
<li>找到与顶点相邻的所有顶点</li>
<li>访问与②中顶点相邻的所有顶点(不重复访问被访问过的结点)</li>
<li>重复③知道所有顶点被访问</li>
</ol>
<p>广度优先遍历要点：</p>
<ol>
<li><p>找到与⼀个顶点相邻的所有顶点 </p>
<ul>
<li><p>FirstNeighbor(G,x)：求图G中顶点x的第⼀个邻接点，若有则返回顶点号，若没有邻接点或图中不存在x，则返回-1</p>
</li>
<li><p>NextNeighbor(G,x,y)：假设图G中顶点y是顶点x的⼀个邻接点，返回除y之外顶点x的下⼀个邻接点的顶点号，若y是x的最后⼀个邻接点，则返回-1</p>
</li>
</ul>
</li>
<li><p>标记哪些顶点被访问过 </p>
</li>
<li><p>需要⼀个辅助队列</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM]; <span class="comment">// 访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 广度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span> &#123; 		<span class="comment">// 从顶点v出发,广度优先遍历图G</span></span><br><span class="line">    visit(v);					<span class="comment">// 访问初始顶点v</span></span><br><span class="line">    visited[v] = TRUE;			<span class="comment">// 对v做已访问标记</span></span><br><span class="line">    Enqueue(Q, v);				<span class="comment">// 顶点v入队列Q</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(Q)) &#123;</span><br><span class="line">        DeQueue(Q, v);			<span class="comment">// 顶点v出队列</span></span><br><span class="line">        <span class="comment">// 检测所有邻接点，令w等于v的第一个邻接点，若返回值不为-1，继续求除了w之外v中的下一个邻接点</span></span><br><span class="line">        <span class="keyword">for</span> (w = FirstNeighbor(G, v); w &gt;= <span class="number">0</span>; w = NextNeighbor(G, v, w)) &#123;</span><br><span class="line">			<span class="comment">// w为v的尚未访问的邻接顶点</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">                visit(w);			<span class="comment">// 访问顶点w</span></span><br><span class="line">                visited[w] = TRUE;	<span class="comment">// 对w做已访问标记</span></span><br><span class="line">                EnQueue(Q, w);		<span class="comment">// 顶点w入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.3.1%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.png" alt="6.3.1图的广度优先遍历"></p>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.3.1%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%861.png" alt="6.3.1图的广度优先遍历1"></p>
<p>2-1-6-5-3-7-4-8</p>
<p>同⼀个图的邻接矩阵表示方式唯⼀，因此广度优先遍历序列唯⼀ </p>
<p>同⼀个图邻接表表示方式不唯⼀，因此广度优先遍历序列不唯⼀</p>
<p>BFS算法(Final版)</p>
<p><strong>如果是非连通图，之前的代码无法遍历完所有结点</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM]; <span class="comment">// 访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 广度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(Graph G)</span> &#123; <span class="comment">// 对图G进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        visited[i] = FALSE;</span><br><span class="line"></span><br><span class="line">    InitQueue(Q);			<span class="comment">//初始化辅助队列Q</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!visited[i])</span><br><span class="line">            <span class="comment">// 广度优先遍历</span></span><br><span class="line">            BFS(G, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    visit(v); <span class="comment">// 访问初始顶点v</span></span><br><span class="line">    visited[v] = TRUE; <span class="comment">// 对v做已访问标记</span></span><br><span class="line">    Enqueue(Q, v); <span class="comment">// 顶点v入队列Q</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(Q)) &#123;</span><br><span class="line">        DeQueue(Q, v); <span class="comment">// 顶点v出队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (w = FirstNeighbor(G, v); w &gt;= <span class="number">0</span>; w = NextNeighbor(G, v, w)) &#123;</span><br><span class="line">            <span class="comment">// 检测所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">                visit(w); <span class="comment">// 访问顶点w</span></span><br><span class="line">                visited[w] = TRUE; <span class="comment">// 对w做已访问标记</span></span><br><span class="line">                EnQueue(Q, w); <span class="comment">// 顶点w入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>广度优先生成树</strong></p>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.3.1%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%94%9F%E6%88%90%E6%A0%91.png" alt="6.3.1广度优先生成树"></p>
<p>对非连通图的⼴度优先遍历，可得到广度优先生成森林</p>
<h3 id="图的深度优先遍历——DFS"><a href="#图的深度优先遍历——DFS" class="headerlink" title="图的深度优先遍历——DFS"></a>图的深度优先遍历——DFS</h3><p>类似于树的先根遍历</p>
<p>可以用来判断有向图中是否有环，如果访问某个节点时，顶点已经被标记，证明有环</p>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.3.2%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" alt="image-20240506133949040"></p>
<ol>
<li>从一个顶点出发，访问该顶点并标记，找到与他相邻的第一个元素</li>
<li>若元素未被标记，访问该顶点并对该顶点进行深度优先遍历</li>
<li>重复②直到所有顶点被访问</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM]; <span class="comment">// 访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    visit(v); <span class="comment">// 访问顶点v</span></span><br><span class="line">    visited[v] = TRUE; <span class="comment">// 设已访问标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从顶点v出发,深度优先遍历图G</span></span><br><span class="line">    <span class="keyword">for</span> (w = FirstNeighbor(G, v); w &gt;= <span class="number">0</span>; w = NextNeighor(G, v, w)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">            <span class="comment">// w为v的尚未访问的邻接顶点</span></span><br><span class="line">            DFS(G, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码对非连通图不适用，优化后</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM]; <span class="comment">// 访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化访问标记数组</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">        visited[v] = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个未访问的顶点调用DFS</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">        <span class="keyword">if</span> (!visited[v])</span><br><span class="line">            DFS(G, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    visit(v); <span class="comment">// 访问顶点v</span></span><br><span class="line">    visited[v] = TRUE; <span class="comment">// 设已访问标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从顶点v出发,深度优先遍历图G</span></span><br><span class="line">    <span class="keyword">for</span> (w = FirstNeighbor(G, v); w &gt;= <span class="number">0</span>; w = NextNeighor(G, v, w)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">            <span class="comment">// w为v的尚未访问的邻接顶点</span></span><br><span class="line">            DFS(G, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.3.1%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.png" alt="6.3.1图的广度优先遍历"></p>
<p>顺序：2 1 5 6 3 4 7 8</p>
<p>深度优先生成树</p>
<img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/思维导图/6.3.2图的深度优先遍历.png" alt="image-20240506133434873" style="zoom:50%;" />

<p><strong>非连通图的深度优先遍历，可得到深度优先生成森林</strong></p>
<h2 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h2><p>本节是大题（应用题）的高频考点，要掌握每个算法的逻辑，不需要深究代码</p>
<p>数据结构只有两个大题：算法题和应用题，算法题需要你写代码，而应用题不要求写代码，只要你理解算法逻辑，能手动模拟算法执行过程就能解题</p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>n个顶点连通图生成树一定<strong>n-1条边</strong>，且不存在回路，但要保持连通</p>
<p>对于一个带权连通无向图G = (V, E)，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设R为G的所有生成树的集合，若T为R中边的权值之和最小的生成树，则T称为G的最小生成树(MST)</p>
<ul>
<li>如果一个连通图本身就是一棵树，则其最小生成树就是它本身</li>
<li>只有连通图才有生成树，非连通图只有生成森林</li>
</ul>
<p>只要无向连通图中没有权值相同的边，不论用什么算法，其最小生成树唯一</p>
<h4 id="Prim算法-普里姆"><a href="#Prim算法-普里姆" class="headerlink" title="Prim算法(普里姆)"></a>Prim算法(普里姆)</h4><p>适用于边稠密图</p>
<ul>
<li><p>从某⼀个顶点开始构建生成树；</p>
</li>
<li><p>每次将代价最小的新顶点纳⼊生成树，直到所有顶点都纳⼊为止</p>
</li>
</ul>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.4.1Prim%E7%AE%97%E6%B3%95.png" alt="image-20240506155420682"></p>
<h4 id="Kruskal算法-克鲁斯卡尔"><a href="#Kruskal算法-克鲁斯卡尔" class="headerlink" title="Kruskal算法(克鲁斯卡尔)"></a>Kruskal算法(克鲁斯卡尔)</h4><p>适用于边稀疏图</p>
<ul>
<li>每次选择⼀条权值最小的边，使这条边的两头连通（原本两头已经连通的就不选）</li>
<li>直到所有结点都连通</li>
</ul>
<img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/思维导图/6.4.1Kruskal算法.png" alt="image-20240506162857067" style="zoom:50%;" />

<p>算法思想：基于并查集</p>
<p>时间复杂度：一共e条边共执行e轮，每轮判断两个集合是否属于同一个集合时间复杂度O($log_2e$)</p>
<p>总时间复杂度O($elog_2e$)</p>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.4.1Kruskal%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3.png" alt="image-20240506172014665"></p>
<ul>
<li>将各条边按照权值排序</li>
<li>把各个顶点看作互不相交的集合，按照权值从小到大把第一个边的两个顶点所在的集合连接起来，看作一个集合</li>
<li>继续进行②直到所有顶点连通</li>
</ul>
<h3 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h3><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/思维导图/6.4.2最短路径问题.png" alt="image-20240506211155609" style="zoom:67%;" />

<p><strong>单源最短路径问题</strong>： A城是个物流集散中心，经常需要往别的城市运东西，怎么运送距离最近</p>
<ul>
<li>BFS算法(无权图)——广度优先遍历</li>
<li>Dijkstra算法(带权图、无权图)</li>
</ul>
<p>每对顶点间的<strong>最短路径</strong>——Floyd算法(带权图、无权图)</p>
<h4 id="1BFS求无权图的单源最短路径"><a href="#1BFS求无权图的单源最短路径" class="headerlink" title=".1BFS求无权图的单源最短路径"></a>.1BFS求无权图的单源最短路径</h4><p>可以看作权全部为1的图，d[]顶点u到其他顶点的最短距离，path[]最短路径从哪个顶点过来</p>
<img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/思维导图/6.4.2.1BFS求无权图的单源最短路径.png" alt="image-20240506174709361" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求顶点u到其他顶点的最短路径</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS_MIN_Distance</span><span class="params">(Graph G, <span class="type">int</span> u)</span> &#123;</span><br><span class="line">    <span class="comment">// d[i]表示从u到i结点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i) &#123;</span><br><span class="line">        <span class="comment">// 初始化路径长度</span></span><br><span class="line">        path[i] = <span class="number">-1</span>; <span class="comment">// 最短路径从哪个顶点过来</span></span><br><span class="line">        d[i] = INFINITY; <span class="comment">// INFINITY 表示无穷大，即表示路径不存在</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d[u] = <span class="number">0</span>; <span class="comment">// 顶点u到自身的距离为0</span></span><br><span class="line">    visited[u] = TRUE; <span class="comment">// 标记顶点u已经访问过</span></span><br><span class="line">    EnQueue(Q, u); <span class="comment">// 将顶点u入队</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(Q)) &#123;</span><br><span class="line">        DeQueue(Q, u); <span class="comment">// 队头元素出队,并把顶点的值传给u</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (w = FirstNeighbor(G, u); w &gt;= <span class="number">0</span>; w = NextNeighbor(G, u, w)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">                <span class="comment">// w为u的尚未访问的邻接顶点</span></span><br><span class="line">                d[w] = d[u] + <span class="number">1</span>; <span class="comment">// 路径长度加1，因为u到w的距离比u到v的距离多1</span></span><br><span class="line">                path[w] = u; <span class="comment">// 最短路径应从u到w</span></span><br><span class="line">                visited[w] = TRUE; <span class="comment">// 设已访问标记</span></span><br><span class="line">                EnQueue(Q, w); <span class="comment">// 顶点w入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="求带权图和无权图的单源最短路径——Dijkstra算法"><a href="#求带权图和无权图的单源最短路径——Dijkstra算法" class="headerlink" title="求带权图和无权图的单源最短路径——Dijkstra算法"></a>求带权图和无权图的单源最短路径——Dijkstra算法</h4><p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.4.2.2Dijkstra%E7%AE%97%E6%B3%95.png" alt="image-20240506175831904"></p>
<ol>
<li><p>循环遍历所有结点，找到还没确定最短路径，且dist最小的顶点$V_i$，令final[i] = true</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">$V_0$</th>
<th align="center">$V_1$</th>
<th align="center">$V_2$</th>
<th align="center">$V_3$</th>
<th align="center">$V_4$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">final[5]</td>
<td align="center">true</td>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">dist[5]</td>
<td align="center">0</td>
<td align="center">10</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">path[5]</td>
<td align="center">-1</td>
<td align="center">0</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">0</td>
</tr>
</tbody></table>
</li>
<li><p>检查所有邻接(紧挨着)自$V_i$的顶点，若其final值为false，若dist更小，则更新dist和path信息</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">$V_0$</th>
<th align="center">$V_1$</th>
<th align="center">$V_2$</th>
<th align="center">$V_3$</th>
<th align="center">$V_4$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">final[5]</td>
<td align="center">true</td>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">dist[5]</td>
<td align="center">0</td>
<td align="center">8</td>
<td align="center">14</td>
<td align="center">7</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">path[5]</td>
<td align="center">-1</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">-1</td>
<td align="center">0</td>
</tr>
</tbody></table>
</li>
<li><p>循环①和②直到final全为true</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">$V_0$</th>
<th align="center">$V_1$</th>
<th align="center">$V_2$</th>
<th align="center">$V_3$</th>
<th align="center">$V_4$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">final[5]</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">dist[5]</td>
<td align="center">0</td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center">7</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">path[5]</td>
<td align="center">-1</td>
<td align="center">4</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>通过dist[i]可以得到$V_0$到$V_i$的最短带权路径长度，通过path可知，$V_0$到$V_i$的最短带权路径</p>
<p>时间复杂度O($|V|^2$)，可以用来求有回路的带权图的最短路径，不适用于带负权值的带权图  </p>
<h4 id="最短路径问题——Floyd算法-带权图、无权图"><a href="#最短路径问题——Floyd算法-带权图、无权图" class="headerlink" title="最短路径问题——Floyd算法(带权图、无权图)"></a>最短路径问题——Floyd算法(带权图、无权图)</h4><p>Floyd算法：求出每⼀对顶点之间的最短路径，可以用于<strong>负权值带权图</strong>，但是不能用于解决带有<strong>负权回路</strong>(包含负权值边的回路)的图</p>
<p>对于n个顶点的图G，求任意⼀对顶点 Vi —&gt; Vj 之间的最短路径可分为如下几个阶段</p>
<ul>
<li><p>#初始：不允许在其他顶点中转，最短路径是？ </p>
<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.4.2.3Floyd%E7%AE%97%E6%B3%95.png" alt="image-20240506192319899"></p>
</li>
<li><p>#0：若允许在 V0 中转，最短路径是？ </p>
<p>若$A^{(k-1)}[i][j] &gt; A^{(k-1)}[i][k] + A^{(k-1)}[k][j] $</p>
<p>则$A^{(k)}[i][j] = A^{(k-1)}[i][k] + A^{(k-1)}[k][j]$，$path^{k}[i][j] = k$</p>
<p>否则$A^{(k)}$和$path^{(k)}$保持原值</p>
<p>例如$A^{(-1)}[2][1] &gt; A^{(-1)}[2][0] + A^{(-1)}[0][1] = 11$</p>
<p>$A^{(0)}[2][1] = 11$</p>
<p>$path^{(k)}[2][1] = 0$</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center">V0</th>
<th align="center">V1</th>
<th align="center">V2</th>
<th align="center"></th>
<th align="center"></th>
<th align="center">V0</th>
<th align="center">V1</th>
<th align="center">V2</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">V0</td>
<td align="center">0</td>
<td align="center">6</td>
<td align="center">13</td>
<td align="center"></td>
<td align="center">V0</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">$A^{0}=$</td>
<td align="center">V1</td>
<td align="center">10</td>
<td align="center">0</td>
<td align="center">4</td>
<td align="center">$path^{0}=$</td>
<td align="center">V1</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">V2</td>
<td align="center">5</td>
<td align="center">==11==</td>
<td align="center">0</td>
<td align="center"></td>
<td align="center">V2</td>
<td align="center">-1</td>
<td align="center">==0==</td>
<td align="center">-1</td>
</tr>
</tbody></table>
</li>
<li><p>#1：若允许在 V0、V1 中转，最短路径是？ </p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center">V0</th>
<th align="center">V1</th>
<th align="center">V2</th>
<th align="center"></th>
<th align="center"></th>
<th align="center">V0</th>
<th align="center">V1</th>
<th align="center">V2</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">V0</td>
<td align="center">0</td>
<td align="center">6</td>
<td align="center">==10==</td>
<td align="center"></td>
<td align="center">V0</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">==1==</td>
</tr>
<tr>
<td align="center">$A^{1}=$</td>
<td align="center">V1</td>
<td align="center">10</td>
<td align="center">0</td>
<td align="center">4</td>
<td align="center">$path^{1}=$</td>
<td align="center">V1</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">V2</td>
<td align="center">5</td>
<td align="center">==11==</td>
<td align="center">0</td>
<td align="center"></td>
<td align="center">V2</td>
<td align="center">-1</td>
<td align="center">==0==</td>
<td align="center">-1</td>
</tr>
</tbody></table>
</li>
<li><p>#2：若允许在 V0、V1、V2 中转，最短路径是？ </p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center">V0</th>
<th align="center">V1</th>
<th align="center">V2</th>
<th align="center"></th>
<th align="center"></th>
<th align="center">V0</th>
<th align="center">V1</th>
<th align="center">V2</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">V0</td>
<td align="center">0</td>
<td align="center">6</td>
<td align="center">==10==</td>
<td align="center"></td>
<td align="center">V0</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">==1==</td>
</tr>
<tr>
<td align="center">$A^{2}=$</td>
<td align="center">V1</td>
<td align="center">==9==</td>
<td align="center">0</td>
<td align="center">4</td>
<td align="center">$path^{2}=$</td>
<td align="center">V1</td>
<td align="center">==2==</td>
<td align="center">-1</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">V2</td>
<td align="center">5</td>
<td align="center">==11==</td>
<td align="center">0</td>
<td align="center"></td>
<td align="center">V2</td>
<td align="center">-1</td>
<td align="center">==0==</td>
<td align="center">-1</td>
</tr>
</tbody></table>
</li>
<li><p>#n-1：若允许在 V0、V1、V2 …… Vn-1 中转，最短路径是？</p>
<p>从$A^{(-1)}$ 和$path^{(-1)}$开始，经过 n 轮递推，得到$A^{(n-1)}$和$path^{(n-1)}$</p>
<p>由$A^{(2)}$可知，V1到V0的最短路径长度为9，根据$path^{(2)}$可知，完整路径信息为V1—V2—V0</p>
</li>
</ul>
<p><strong>代码实现</strong>，时间复杂度O($|V|^3$)，空间复杂度O($|V|^2$)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//准备工作，根据图的信息初始化矩阵A和path如上图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123; <span class="comment">// 以顶点 Vk 作为中转点，从V0到Vn</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 遍历整个矩阵，i为行号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">// j为列号</span></span><br><span class="line">            <span class="keyword">if</span> (A[i][j] &gt; A[i][k] + A[k][j]) &#123; <span class="comment">// 以Vk为中转点的路径更短</span></span><br><span class="line">                A[i][j] = A[i][k] + A[k][j]; <span class="comment">// 更新最短路径长度</span></span><br><span class="line">                path[i][j] = k; <span class="comment">// 中转点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.4.2.3Floyd%E7%AE%97%E6%B3%95%E5%AE%9E%E4%BE%8B.png" alt="image-20240506205913654"></p>
<h3 id="有向无环图描述表达式"><a href="#有向无环图描述表达式" class="headerlink" title="有向无环图描述表达式"></a>有向无环图描述表达式</h3><p>有向无环图：若⼀个有向图中<strong>不存在环</strong>，则称为有向无环图，简称DAG图<br>$$<br>((a+b)<em>(b</em> (c + d)) + (c + d) * e) * ((c + d) * e)<br>$$</p>
<ol>
<li><p>把各个操作数不重复地排成⼀排</p>
<p>a b c d e </p>
</li>
<li><p>标出各个运算符的生效顺序（先后顺序有点出入无所谓）</p>
<img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/思维导图/6.4.3有向无环图描述表达式.png" alt="image-20240506213204634" style="zoom:50%;" /></li>
<li><p>按顺序加⼊运算符，注意分层</p>
<img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/思维导图/6.4.3有向无环图描述表达式1.png" alt="image-20240506213742949" style="zoom:50%;" /></li>
<li><p>从底向上逐层检查同层的运算符是否可以合体</p>
<p>由于第一层的后三个<code>＋</code>号左右操作数都是c、d，因此可以合并为一个</p>
<p>由于第二层的后两个<code>*</code>号左右操作数都是c+d、e，因此可以合并为一个</p>
<p>合并就是把本该由它指向的点由它合并后的点指向，指向它的点改为指向合并后的点</p>
</li>
<li><p>最终结果</p>
<img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/思维导图/6.4.3有向无环图描述表达式2.png" alt="image-20240506214536338" style="zoom:50%;" /></li>
</ol>
<h3 id="DAG应用——拓扑排序"><a href="#DAG应用——拓扑排序" class="headerlink" title="DAG应用——拓扑排序"></a>DAG应用——拓扑排序</h3><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/思维导图/6.4.4DAG应用——拓扑排序.png" alt="image-20240506225420171" style="zoom: 67%;" />

<p>AOV网(Activity On Vertex NetWork，⽤顶点表示活动的网)一定是<strong>有向无环图</strong></p>
<p>有向无环图：若⼀个有向图中<strong>不存在环</strong>，则称为有向无环图，<strong>简称DAG图</strong>，不论是否连通</p>
<p>⽤DAG图(有向无环图)表示⼀个工程。顶点表示活动，有向边表示活动Vi必须先于活动Vj进⾏</p>
<img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/思维导图/6.4.4AOV网.png" alt="image-20240506220211229" style="zoom: 67%;" />

<p>拓扑排序：拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶点B的路径，则在排序中顶点B出现在顶点A的后面。每个AOV网都有一个或多个拓扑排序序列</p>
<p>拓扑排序实现</p>
<ol>
<li>从AOV网中选择⼀个没有前驱（入度为0）的顶点并输出</li>
<li>从网中删除该顶点和所有以它为起点的有向边</li>
<li>重复①和②直到当前的AOV网为空或当前网中不存在无前驱的顶点为止</li>
</ol>
<p>代码实现</p>
<ul>
<li>indegree[]：每一个结点当前顶点入度</li>
<li>print[]：记录拓扑排序序列</li>
<li>可以用栈或者队列暂存元素</li>
<li>时间复杂度：O(|V|+|E|)，若采用邻接矩阵则需要$O(|V|^2)$</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基于邻接表实现</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TopologicalSort</span><span class="params">(Graph G)</span> &#123;</span><br><span class="line">    InitStack(S); <span class="comment">// 初始化栈,存储入度为0的顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">        <span class="comment">//寻找入度为0的顶点</span></span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            Push(S, i); <span class="comment">// 将所有入度为0的顶点入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 计数,记录当前已经输出的顶点数</span></span><br><span class="line">    <span class="keyword">while</span> (!IsEmpty(S)) &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        Pop(S, i); <span class="comment">// 栈顶元素出栈(先进后出)</span></span><br><span class="line">        print[count++] = i; <span class="comment">// 输出顶点i，并把顶点添加到print(拓扑排序序列)中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历顶点 i 对应的邻接表中的所有边，只要p不为空指针就一直循环</span></span><br><span class="line">        <span class="keyword">for</span> (ArcNode *p = G.vertices[i].firstarc; p; p = p-&gt;nextarc) &#123;</span><br><span class="line">            <span class="comment">// 将所有i指向的顶点的入度减1,并且将入度减为0的顶点压入栈s</span></span><br><span class="line">            <span class="type">int</span> v = p-&gt;adjvex;	<span class="comment">// 让v等于边指向的顶点</span></span><br><span class="line">            <span class="comment">//让v的入度减一，如果减一后入度为0，则把顶点v入栈</span></span><br><span class="line">            <span class="keyword">if</span> (!(--indegree[v])) &#123;	</span><br><span class="line">                Push(S, v); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &lt; G.vexnum) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 排序失败,有向图中有回路</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 拓扑排序成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>逆拓扑排序</strong></p>
<p>对一个AOV网，如果采用下列步骤进行排序，则称之为逆拓扑排序：</p>
<ol>
<li><p>从AOV网中选择一个没有后继（出度为0）的顶点并输出</p>
</li>
<li><p>从网中删除该顶点和所有以它为终点的向边</p>
</li>
<li><p>重复①和②直到当前的AOV网为</p>
</li>
</ol>
<p>使用<strong>邻接矩阵</strong>表示图更高效</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">InitStack(S); <span class="comment">// 初始化栈,存储出度为0的顶点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ReverseTopologicalSort</span><span class="params">(Graph G)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (outdegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            Push(S, i); <span class="comment">// 将所有出度为0的顶点进栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数,记录当前已经输出的顶点数</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!IsEmpty(S)) &#123; <span class="comment">// 栈不空,则存在出度为0的顶点</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        Pop(S, i); <span class="comment">// 栈顶元素出栈</span></span><br><span class="line">        print[count++] = i; <span class="comment">// 输出顶点i</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将所有指向顶点i的顶点的出度减1,并且将出度减为0的顶点压入栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (G.arcs[j][i] == <span class="number">1</span>) &#123; <span class="comment">// 如果顶点j指向顶点i</span></span><br><span class="line">                G.arcs[j][i] = <span class="number">0</span>; <span class="comment">// 删除这条边</span></span><br><span class="line">                outdegree[i]--; <span class="comment">// 顶点i的出度减1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (outdegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    Push(S, i); <span class="comment">// 出度为0,则入栈</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &lt; G.vexnum) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 排序失败,有向图中有回路</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 逆拓扑排序成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>DFS算法实现逆拓扑排序</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM]; <span class="comment">// 访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化访问标记数组</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">        visited[v] = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个未访问的顶点调用DFS</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">        <span class="keyword">if</span> (!visited[v])</span><br><span class="line">            DFS(G, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    visited[v] = TRUE; <span class="comment">// 设已访问标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从顶点v出发,深度优先遍历图G</span></span><br><span class="line">    <span class="keyword">for</span> (w = FirstNeighbor(G, v); w &gt;= <span class="number">0</span>; w = NextNeighor(G, v, w)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">            <span class="comment">// w为v的尚未访问的邻接顶点</span></span><br><span class="line">            DFS(G, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(v);	<span class="comment">//输出顶点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/6.4.5%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84.png" alt="image-20240507202612723"></p>
<p>在带权有向图中，以<strong>顶点表示事件</strong>，以<strong>有向边表示活动</strong>，以边上的权值表示完成该活动的开销(如完成活动所需的时间)，称之为用边表示活动的网络，简称AOE网</p>
<img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/思维导图/6.4.5AOE网.png" alt="image-20240507193411163" style="zoom: 50%;" />

<p>AOE网具有以下两个性质：</p>
<ul>
<li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始</li>
<li>只有在进入某顶点的个邮箱边所代表的活动都已结束时，该顶点所代表的事件才能发生</li>
<li>有些活动是可以并行进行的，例如开始后洗番茄和打鸡蛋可以同时进行</li>
</ul>
<p>AOE的开始和结束</p>
<ul>
<li><p>在AOE网中仅有一个入度为零的顶点，称为开始顶点(源点)，他表示整个工程的开始</p>
</li>
<li><p>也仅有一个出度为零的顶点，称为结束顶点(汇点)，他表示整个工程的结束</p>
</li>
<li><p>从源点到汇点的有向路径可能有多条，<strong>所有路径中具有最大路径长度的路径称为关键路径</strong>，儿把关键路径上的活动称为关键活动</p>
</li>
<li><p>完成整个工程的<strong>最短时间</strong>就是关键路径长度</p>
</li>
<li><p>若关键活动耗时增加，则整个工程的工期增加</p>
</li>
<li><p>缩短关键活动的时间，可以缩短整个工程的工期。当缩短到一定程度时，关键活动可能会变成<strong>非关键活动</strong></p>
</li>
<li><p>当有多条关键路径时，需要==同时缩短所有关键路径==，整个工期才会缩短</p>
</li>
</ul>
<p>活动a的<strong>最早开始时间</strong>：指该活动弧的起点所表示的事件的最早发生时间</p>
<p>例如炒鸡蛋的活动弧的起点是V1，最早开始时间是0</p>
<p>活动a的<strong>最迟开始时间</strong>：指活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差</p>
<p>例如炒鸡蛋的活动弧的终点V3最迟发生时间和a1打鸡蛋的时间只差为2，因此打鸡蛋最迟开始时间为2</p>
<p>活动ai的<strong>时间余量</strong>：表示在不增加完成整工程所需总时间的情况下，活动ai可以拖延的时间</p>
<p><strong>求关键路径的步骤</strong></p>
<img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/思维导图/6.4.5求关键路径步骤.png" alt="image-20240507200445536" style="zoom: 50%;" />

<ol>
<li><p>求所有事件的最早发生时间ve()</p>
<p>对顶点进行==拓扑排序==，然后根据拓扑序列求最早发生时间</p>
<p>ve(源点)=0</p>
<p>ve(k) = Max{ve(j) + Weight(vj,vk)}，vj为vk的任意前驱</p>
<img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/思维导图/6.4.5求所有时间的最迟发生时间.png" alt="image-20240507200743615" style="zoom: 50%;" /></li>
<li><p>求所有事件的最迟发生时间vl()</p>
<p>==逆拓扑排序==后，对逆拓扑序列依次求最迟发生时间</p>
<p>vl(汇点) = ve(汇点)</p>
<p>vl(k) = Min{vl(j) - Weight(vk,vj)}，vj为vk的任意后继</p>
<img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/408/思维导图/6.4.5求所有时间的最早发生时间.png" alt="image-20240507200921383" style="zoom:50%;" /></li>
<li><p>求所有活动的最早发生时间e()</p>
<p>e(i) = ve(k)，k为活动弧起点代表的事件</p>
</li>
<li><p>求所有活动的最迟发生时间l()</p>
<p>l(i) = vl(j) - Weight(vk,vj)，j为活动弧终点所代表的事件</p>
</li>
<li><p>求所有活动的时间余量d()</p>
<p>d(i) = l(i) - e(i)</p>
</li>
<li><p>活动余量为0的活动是关键活动，由关键活动组成的路径就是关键路径</p>
</li>
<li><p>可以有多条关键路径</p>
</li>
</ol>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/2.jpg" data-sites="wechat,weibo,qq,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/alipay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/wechat.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Snoopy</div><div class="author-info__description">青青草原最会编程的羊</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/new-zxp"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/new-zxp" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxkk3851@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><div style="font-size: 18px; font-weight: bold; text-align: center;">
  🎉欢迎来到我的blog🎉
</div>
</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB"><span class="toc-number">1.</span> <span class="toc-text">杂七杂八</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%AA%E8%AE%BA"><span class="toc-number">2.</span> <span class="toc-text">绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">数据结构的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7"><span class="toc-number">2.2.</span> <span class="toc-text">算法和算法评价</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.2.1.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.2.2.</span> <span class="toc-text">空间复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.</span> <span class="toc-text">线性表的定义和基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">线性表的顺序表示——顺序表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">线性表的链式表示——链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">单链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">双链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.3.</span> <span class="toc-text">循环链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">循环单链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">循环双链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.4.</span> <span class="toc-text">静态链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E6%AF%94%E8%BE%83"><span class="toc-number">3.3.5.</span> <span class="toc-text">顺序表和链表比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">4.</span> <span class="toc-text">栈、队列和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">4.1.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.1.</span> <span class="toc-text">栈的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="toc-number">4.1.2.</span> <span class="toc-text">栈的顺序存储结构——顺序栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A0%88"><span class="toc-number">4.1.3.</span> <span class="toc-text">共享栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%A0%88"><span class="toc-number">4.1.4.</span> <span class="toc-text">链栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">4.2.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">队列的顺序结构实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E9%98%9F%E5%88%97"><span class="toc-number">4.2.2.</span> <span class="toc-text">队列的链式存储结构——链队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.2.3.</span> <span class="toc-text">双端队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">栈和队列的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%9C%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text">栈在括号匹配中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.3.2.</span> <span class="toc-text">栈在表达式求值中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">中缀转后缀（重点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%89%8D%E7%BC%80"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">中缀转前缀</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%9C%A8%E9%80%92%E5%BD%92%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.3.3.</span> <span class="toc-text">栈在递归中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%9C%A8%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.3.4.</span> <span class="toc-text">队列在层次遍历中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.3.5.</span> <span class="toc-text">队列在操作系统中的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5"><span class="toc-number">4.4.</span> <span class="toc-text">数组和特殊矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.4.1.</span> <span class="toc-text">数组的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">4.4.2.</span> <span class="toc-text">特殊矩阵的压缩存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%B2"><span class="toc-number">5.</span> <span class="toc-text">串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.1.</span> <span class="toc-text">串的定义和实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">5.2.</span> <span class="toc-text">串的模式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.1.</span> <span class="toc-text">简单的模式匹配算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kmp%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.2.</span> <span class="toc-text">kmp算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">树与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">树的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">6.2.</span> <span class="toc-text">二叉树的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">6.2.1.</span> <span class="toc-text">二叉树的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.2.</span> <span class="toc-text">二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">.1二叉树的顺序存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">二叉树的链式存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.3.</span> <span class="toc-text">二叉树的遍历和线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">6.3.1.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.3.1.1.</span> <span class="toc-text">二叉树的先、中、后序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.3.1.2.</span> <span class="toc-text">二叉树的层序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.3.1.3.</span> <span class="toc-text">由遍历序列构造二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.3.2.</span> <span class="toc-text">线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">.1线索化二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%89%8D%E9%A9%B1%E5%92%8C%E5%90%8E%E7%BB%A7"><span class="toc-number">6.3.2.2.</span> <span class="toc-text">在线索二叉树中找前驱和后继</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97"><span class="toc-number">6.4.</span> <span class="toc-text">树、森林</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">6.4.1.</span> <span class="toc-text">树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">6.4.1.1.</span> <span class="toc-text">双亲表示法(顺序存储)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95-%E9%A1%BA%E5%BA%8F-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">6.4.1.2.</span> <span class="toc-text">孩子表示法(顺序+链式存储)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">6.4.1.3.</span> <span class="toc-text">孩子兄弟表示法(链式存储)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.4.2.</span> <span class="toc-text">树、森林与二叉树的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.4.2.1.</span> <span class="toc-text">树转二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.4.2.2.</span> <span class="toc-text">森林转二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%A0%91"><span class="toc-number">6.4.2.3.</span> <span class="toc-text">二叉树转树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%A3%AE%E6%9E%97"><span class="toc-number">6.4.2.4.</span> <span class="toc-text">二叉树转森林</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">6.4.3.</span> <span class="toc-text">树和森林的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">6.5.</span> <span class="toc-text">树与二叉树的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">6.5.1.</span> <span class="toc-text">哈夫曼树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">6.5.2.</span> <span class="toc-text">并查集</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">7.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">图的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">7.2.</span> <span class="toc-text">图的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95"><span class="toc-number">7.2.1.</span> <span class="toc-text">邻接矩阵法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95-%E9%A1%BA%E5%BA%8F-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">7.2.2.</span> <span class="toc-text">邻接表法(顺序+链式存储)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-number">7.2.3.</span> <span class="toc-text">十字链表(链式存储有向图)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E5%AD%98%E5%82%A8%E6%97%A0%E5%90%91%E5%9B%BE"><span class="toc-number">7.2.4.</span> <span class="toc-text">邻接多重表存储无向图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">7.2.5.</span> <span class="toc-text">图的基本操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">7.3.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E2%80%94%E2%80%94BFS"><span class="toc-number">7.3.1.</span> <span class="toc-text">图的广度优先遍历——BFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E2%80%94%E2%80%94DFS"><span class="toc-number">7.3.2.</span> <span class="toc-text">图的深度优先遍历——DFS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">7.4.</span> <span class="toc-text">图的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">7.4.1.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95-%E6%99%AE%E9%87%8C%E5%A7%86"><span class="toc-number">7.4.1.1.</span> <span class="toc-text">Prim算法(普里姆)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94"><span class="toc-number">7.4.1.2.</span> <span class="toc-text">Kruskal算法(克鲁斯卡尔)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">7.4.2.</span> <span class="toc-text">最短路径问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1BFS%E6%B1%82%E6%97%A0%E6%9D%83%E5%9B%BE%E7%9A%84%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">7.4.2.1.</span> <span class="toc-text">.1BFS求无权图的单源最短路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E5%B8%A6%E6%9D%83%E5%9B%BE%E5%92%8C%E6%97%A0%E6%9D%83%E5%9B%BE%E7%9A%84%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E2%80%94%E2%80%94Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-number">7.4.2.2.</span> <span class="toc-text">求带权图和无权图的单源最短路径——Dijkstra算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94Floyd%E7%AE%97%E6%B3%95-%E5%B8%A6%E6%9D%83%E5%9B%BE%E3%80%81%E6%97%A0%E6%9D%83%E5%9B%BE"><span class="toc-number">7.4.2.3.</span> <span class="toc-text">最短路径问题——Floyd算法(带权图、无权图)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E6%8F%8F%E8%BF%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">7.4.3.</span> <span class="toc-text">有向无环图描述表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DAG%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">7.4.4.</span> <span class="toc-text">DAG应用——拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">7.4.5.</span> <span class="toc-text">关键路径</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024-02-29-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" title="数据结构"><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构"/></a><div class="content"><a class="title" href="/2024-02-29-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" title="数据结构">数据结构</a><time datetime="2024-02-29T01:56:41.000Z" title="发表于 2024-02-29 09:56:41">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023-08-09-c.html" title="c语言笔记"><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c语言笔记"/></a><div class="content"><a class="title" href="/2023-08-09-c.html" title="c语言笔记">c语言笔记</a><time datetime="2023-08-09T01:56:41.000Z" title="发表于 2023-08-09 09:56:41">2023-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023-01-16-Greenland.html" title="格陵兰冰盖多要素监测网络平台"><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="格陵兰冰盖多要素监测网络平台"/></a><div class="content"><a class="title" href="/2023-01-16-Greenland.html" title="格陵兰冰盖多要素监测网络平台">格陵兰冰盖多要素监测网络平台</a><time datetime="2023-01-16T02:00:00.000Z" title="发表于 2023-01-16 10:00:00">2023-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022-11-16-TT%E5%A4%96%E5%8D%96.html" title="TT外卖项目开发"><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/11.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TT外卖项目开发"/></a><div class="content"><a class="title" href="/2022-11-16-TT%E5%A4%96%E5%8D%96.html" title="TT外卖项目开发">TT外卖项目开发</a><time datetime="2022-11-16T02:00:00.000Z" title="发表于 2022-11-16 10:00:00">2022-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022-08-27-%E5%89%8D%E7%AB%AF.html" title="前端"><img src="https://zhuxinpeng.oss-cn-hangzhou.aliyuncs.com/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端"/></a><div class="content"><a class="title" href="/2022-08-27-%E5%89%8D%E7%AB%AF.html" title="前端">前端</a><time datetime="2022-08-27T02:37:48.000Z" title="发表于 2022-08-27 10:37:48">2022-08-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Snoopy</div><div class="framework-info"></div><div class="footer_custom_text">欢迎来到我的blog</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>